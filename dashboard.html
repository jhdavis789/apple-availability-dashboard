<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Apple Product Availability Dashboard</title>
  <!-- Google Analytics 4 -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-9XP43TXQ0T"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-9XP43TXQ0T');
  </script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/d3-delaunay@6.0.4/dist/d3-delaunay.min.js"></script>
  <style>
    :root {
      --bg: #0a0a0a;
      --text: #e0e0e0;
      --text-white: #fff;
      --text-muted: #888;
      --text-dim: #666;
      --text-dimmer: #555;
      --text-label: #aaa;
      --text-filter: #bbb;
      --text-secondary-btn: #aaa;
      --text-secondary-btn-hover: #ddd;
      --header-bg: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      --header-border: #2a2a4a;
      --controls-bg: #111;
      --controls-border: #222;
      --card-bg: #141414;
      --card-border: #222;
      --input-bg: #1a1a2e;
      --input-border: #333;
      --input-border-hover: #555;
      --accent: #0a84ff;
      --accent-hover: #0070e0;
      --secondary-border: #444;
      --secondary-border-hover: #666;
      --grid-color: #1a1a1a;
      --tick-color: #666;
      --tooltip-bg: #1a1a2e;
      --tooltip-border: #333;
      --summary-bg: #1a1a2e;
      --summary-border: #2a2a4a;
      --footer-border: #222;
      --slider-track: #333;
      --range-input-scheme: dark;
    }
    html[data-theme="light"] {
      --bg: #f5f5f7;
      --text: #1d1d1f;
      --text-white: #000;
      --text-muted: #6e6e73;
      --text-dim: #86868b;
      --text-dimmer: #aeaeb2;
      --text-label: #6e6e73;
      --text-filter: #3a3a3c;
      --text-secondary-btn: #6e6e73;
      --text-secondary-btn-hover: #1d1d1f;
      --header-bg: linear-gradient(135deg, #e8e8ed 0%, #d2d2d7 100%);
      --header-border: #c7c7cc;
      --controls-bg: #ececf0;
      --controls-border: #d1d1d6;
      --card-bg: #fff;
      --card-border: #d1d1d6;
      --input-bg: #fff;
      --input-border: #c7c7cc;
      --input-border-hover: #8e8e93;
      --accent: #0071e3;
      --accent-hover: #0060c0;
      --secondary-border: #c7c7cc;
      --secondary-border-hover: #8e8e93;
      --grid-color: #e5e5ea;
      --tick-color: #86868b;
      --tooltip-bg: #fff;
      --tooltip-border: #d1d1d6;
      --summary-bg: #f5f5f7;
      --summary-border: #d1d1d6;
      --footer-border: #d1d1d6;
      --slider-track: #c7c7cc;
      --range-input-scheme: light;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    .header {
      background: var(--header-bg);
      padding: 24px 32px;
      border-bottom: 1px solid var(--header-border);
      position: relative;
    }
    .header h1 {
      font-size: 24px;
      font-weight: 600;
      color: var(--text-white);
      margin-bottom: 4px;
    }
    .header .subtitle {
      font-size: 13px;
      color: var(--text-muted);
    }
    .header-top-right {
      position: absolute;
      top: 24px;
      right: 32px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    .last-updated-badge {
      font-size: 11px;
      color: var(--text-muted);
      white-space: nowrap;
    }
    .theme-toggle {
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      transition: background 0.2s, border-color 0.2s;
      padding: 0;
    }
    .theme-toggle:hover {
      border-color: var(--input-border-hover);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      padding: 20px 32px;
      background: var(--controls-bg);
      border-bottom: 1px solid var(--controls-border);
      align-items: flex-end;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .control-group label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      font-weight: 600;
    }
    select, button {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 13px;
      cursor: pointer;
      outline: none;
    }
    select:hover, button:hover { border-color: var(--input-border-hover); }
    select:focus, button:focus { border-color: var(--accent); }
    select[multiple] {
      min-height: 120px;
      min-width: 180px;
    }
    button {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
      font-weight: 600;
      padding: 8px 20px;
    }
    button:hover { background: var(--accent-hover); }
    button.secondary {
      background: transparent;
      border-color: var(--secondary-border);
      color: var(--text-secondary-btn);
    }
    button.secondary:hover { border-color: var(--secondary-border-hover); color: var(--text-secondary-btn-hover); }

    .filter-toggles {
      display: flex;
      gap: 12px;
      align-items: center;
    }
    .toggle-label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 13px;
      color: var(--text-filter);
      cursor: pointer;
    }
    .toggle-label input[type="checkbox"] {
      accent-color: var(--accent);
      width: 16px;
      height: 16px;
    }

    .dashboard {
      padding: 24px 32px;
      display: flex;
      flex-direction: column;
      gap: 24px;
    }
    .chart-card {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 12px;
      padding: 20px;
    }
    .chart-card h3 {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 16px;
      color: var(--text-white);
    }
    .chart-container {
      position: relative;
      height: 350px;
    }
    .summary-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
    }
    .summary-card {
      background: var(--summary-bg);
      border: 1px solid var(--summary-border);
      border-radius: 10px;
      padding: 16px;
      text-align: center;
    }
    .summary-card .city-name {
      font-size: 13px;
      color: var(--text-muted);
      margin-bottom: 6px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .summary-card .avg-val {
      font-size: 32px;
      font-weight: 700;
    }
    .summary-card .label {
      font-size: 11px;
      color: var(--text-dim);
      margin-top: 2px;
    }
    .good { color: #30d158; }
    .ok { color: #ffd60a; }
    .bad { color: #ff453a; }
    .neutral { color: #8e8e93; }

    .period-btns { display: flex; gap: 4px; margin-bottom: 14px; }
    .period-btn {
      padding: 5px 12px; font-size: 11px; border-radius: 5px;
      background: transparent; border: 1px solid var(--input-border); color: var(--text-muted);
      cursor: pointer; font-weight: 600;
    }
    .period-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
    .period-btn.disabled { opacity: 0.3; cursor: default; pointer-events: none; }

    .movers-row {
      display: flex; gap: 10px; flex-wrap: wrap;
      margin-top: 14px; padding-top: 14px; border-top: 1px solid var(--card-border);
    }
    .summary-card .delta-val {
      font-size: 20px;
      font-weight: 700;
      margin-top: 2px;
    }
    .summary-card .sub-label {
      font-size: 10px;
      color: var(--text-dimmer);
      margin-top: 2px;
    }

    .view-tabs {
      display: flex;
      gap: 4px;
    }
    .view-tab {
      padding: 6px 14px;
      font-size: 12px;
      border-radius: 6px;
      background: transparent;
      border: 1px solid var(--input-border);
      color: var(--text-muted);
      cursor: pointer;
    }
    .view-tab.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .heatmap-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }
    .heatmap-table th, .heatmap-table td {
      padding: 8px 10px;
      text-align: center;
      border: 1px solid var(--card-border);
    }
    .heatmap-table th {
      background: var(--summary-bg);
      color: var(--text-label);
      font-weight: 600;
      position: sticky;
      top: 0;
    }
    .heatmap-table th:first-child, .heatmap-table td:first-child {
      text-align: left;
      min-width: 140px;
      font-weight: 600;
    }
    .stats-row {
      display: flex;
      gap: 24px;
      flex-wrap: wrap;
    }
    .stat-box {
      background: var(--summary-bg);
      border: 1px solid var(--summary-border);
      border-radius: 10px;
      padding: 16px 24px;
      flex: 1;
      min-width: 150px;
    }
    .stat-box .stat-label {
      font-size: 11px;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .stat-box .stat-value {
      font-size: 28px;
      font-weight: 700;
      color: var(--text-white);
    }
    #loading {
      text-align: center;
      padding: 80px;
      color: var(--text-dim);
      font-size: 16px;
    }
    .excluded-info {
      font-size: 11px;
      color: var(--text-dim);
      padding: 4px 0;
    }

    /* Time range slider */
    .time-range-group {
      min-width: 320px;
    }
    .time-range-inputs {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    .time-range-inputs input[type="datetime-local"] {
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 12px;
      outline: none;
      flex: 1;
      color-scheme: var(--range-input-scheme);
    }
    .time-range-inputs input[type="datetime-local"]:focus {
      border-color: var(--accent);
    }
    .time-range-inputs span {
      color: var(--text-dim);
      font-size: 12px;
    }
    .dual-range {
      position: relative;
      height: 24px;
      width: 100%;
    }
    .dual-range input[type="range"] {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 24px;
      margin: 0;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
      background: transparent;
      outline: none;
    }
    .dual-range input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid var(--text-white);
      cursor: pointer;
      pointer-events: all;
      position: relative;
      z-index: 2;
    }
    .dual-range input[type="range"]::-moz-range-thumb {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid var(--text-white);
      cursor: pointer;
      pointer-events: all;
    }
    .dual-range .track {
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--slider-track);
      border-radius: 2px;
    }
    .dual-range .track-fill {
      position: absolute;
      top: 10px;
      height: 4px;
      background: var(--accent);
      border-radius: 2px;
    }
    .time-range-label {
      font-size: 11px;
      color: var(--text-dim);
      text-align: center;
      margin-top: 2px;
    }
    .time-range-reset {
      background: transparent;
      border: 1px solid var(--secondary-border);
      color: var(--text-label);
      padding: 4px 10px;
      font-size: 11px;
      border-radius: 4px;
      cursor: pointer;
      white-space: nowrap;
    }
    .time-range-reset:hover { border-color: var(--secondary-border-hover); color: var(--text-secondary-btn-hover); }

    /* Map container */
    #mapContainer {
      width: 100%;
      height: 600px;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }
    #mapContainer .leaflet-container {
      background: var(--card-bg);
    }
    .map-legend {
      background: var(--card-bg);
      border: 1px solid var(--card-border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text);
      line-height: 1.6;
    }
    .map-legend-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 4px;
      vertical-align: middle;
    }
    .map-tooltip {
      background: var(--tooltip-bg);
      border: 1px solid var(--tooltip-border);
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 12px;
      color: var(--text);
      pointer-events: none;
      position: absolute;
      z-index: 1000;
      white-space: nowrap;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    /* Map controls bar */
    .map-controls {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 0;
      flex-wrap: wrap;
    }
    .map-controls label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      font-weight: 600;
    }
    .map-time-slider {
      flex: 1;
      min-width: 200px;
    }
    .map-time-slider input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
    }
    .map-time-label {
      font-size: 11px;
      color: var(--text-dim);
      text-align: center;
      margin-top: 2px;
    }
    .map-mode-btns {
      display: flex;
      gap: 4px;
    }
    .map-mode-btn {
      padding: 5px 12px;
      font-size: 11px;
      border-radius: 5px;
      background: transparent;
      border: 1px solid var(--input-border);
      color: var(--text-muted);
      cursor: pointer;
      font-weight: 600;
    }
    .map-mode-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }
    .map-delta-range {
      display: flex;
      gap: 8px;
      align-items: center;
      flex: 1;
      min-width: 200px;
    }
    .map-delta-range input[type="range"] {
      flex: 1;
      accent-color: var(--accent);
    }
    /* Hide main controls in heatmap view */
    body.heatmap-view .controls .control-group:not(.map-keep) {
      display: none;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Apple Product Availability Tracker</h1>
    <div class="subtitle">Pickup availability across 12 US cities</div>
    <div class="subtitle" style="margin-top:8px;font-size:13px;"><span style="background:#ffd60a;color:#000;padding:4px 8px;border-radius:4px;text-decoration:underline;font-weight:600;">‚ö†Ô∏è Percentages = % of stores with at least one unit in stock (not inventory depth)</span></div>
    <div class="subtitle" style="margin-top:6px;font-size:12px;color:var(--text-dim);">‚ÑπÔ∏è iPhone and some other products are no longer tracked to prioritize API availability for more relevant products. They were consistently available (~95-100%).</div>
    <div class="header-top-right">
      <span class="last-updated-badge" id="lastUpdated"></span>
      <span class="last-updated-badge" id="lastUpdatedSite" style="opacity:0.7;"></span>
      <button class="theme-toggle" id="themeToggle" title="Toggle light/dark mode" aria-label="Toggle light/dark mode">üåô</button>
    </div>
  </div>

  <div class="controls" id="controls">
    <div class="control-group map-keep">
      <label>View</label>
      <div class="view-tabs" id="viewTabs">
        <div class="view-tab active" data-view="trends">Trends</div>
        <div class="view-tab" data-view="heatmap">Heatmap</div>
      </div>
    </div>

    <div class="control-group map-keep">
      <label>Product</label>
      <select id="productSelect"></select>
    </div>

    <div class="control-group">
      <label>Cities</label>
      <div style="display:flex;gap:8px;align-items:flex-start;">
        <select id="citySelect" multiple></select>
        <div style="display:flex;flex-direction:column;gap:4px;">
          <button id="selectAllCities" class="secondary" style="font-size:11px;padding:4px 8px;">All</button>
          <button id="clearCities" class="secondary" style="font-size:11px;padding:4px 8px;">None</button>
        </div>
      </div>
    </div>

    <div class="control-group">
      <label>Custom Avg (city names, comma-sep)</label>
      <input type="text" id="customAvgInput" placeholder="e.g. NYC, LA, SF" style="background:var(--input-bg);color:var(--text);border:1px solid var(--input-border);padding:8px 12px;border-radius:6px;font-size:13px;outline:none;min-width:200px;">
    </div>

    <div class="control-group">
      <label>Data Filters</label>
      <div class="filter-toggles">
        <label class="toggle-label">
          <input type="checkbox" id="filterZeros" checked>
          Filter likely errors?
        </label>
        <label class="toggle-label">
          <input type="checkbox" id="showAvailability" checked>
          Show Availability
        </label>
        <label class="toggle-label" id="ebayToggleLabel" style="display:none;">
          <input type="checkbox" id="showEbayPrices">
          Show eBay Prices
        </label>
        <label class="toggle-label ebay-sub-toggle" id="ebayMeanLabel" style="display:none;margin-left:24px;opacity:0.4;pointer-events:none;">
          <input type="checkbox" id="showEbayMean" checked>
          Mean
        </label>
        <label class="toggle-label ebay-sub-toggle" id="ebayMedianLabel" style="display:none;margin-left:24px;opacity:0.4;pointer-events:none;">
          <input type="checkbox" id="showEbayMedian">
          Median
        </label>
      </div>
    </div>

    <div class="control-group time-range-group">
      <label>Time Range</label>
      <div class="period-btns" id="timeRangePeriodBtns" style="margin-bottom:8px;">
        <button class="period-btn" data-hours="24">24h</button>
        <button class="period-btn" data-hours="168">7d</button>
        <button class="period-btn" data-hours="336">2wk</button>
        <button class="period-btn active" data-hours="0">Max</button>
      </div>
      <div class="time-range-inputs">
        <input type="datetime-local" id="timeStart" step="1">
        <span>to</span>
        <input type="datetime-local" id="timeEnd" step="1">
        <button class="time-range-reset" id="timeReset">Reset</button>
      </div>
      <div class="dual-range" id="dualRange">
        <div class="track"></div>
        <div class="track-fill" id="trackFill"></div>
        <input type="range" id="rangeStart" min="0" max="1000" value="0">
        <input type="range" id="rangeEnd" min="0" max="1000" value="1000">
      </div>
    </div>

    <div class="control-group">
      <label>&nbsp;</label>
      <div style="display:flex;gap:8px;">
        <button id="resetCities" class="secondary">Reset</button>
      </div>
    </div>
  </div>

  <div id="loading">Loading data...</div>

  <div class="dashboard" id="dashboard" style="display:none;">
    <!-- Heatmap view (hidden by default, first in stack so it's on top) -->
    <div class="chart-card" id="heatmapCard" style="display:none;">
      <h3>Store Availability Map</h3>
      <div class="map-controls">
        <div class="map-mode-btns">
          <button class="map-mode-btn active" data-mode="snapshot">Snapshot</button>
          <button class="map-mode-btn" data-mode="delta">Delta</button>
        </div>
        <div id="mapSnapshotControls" class="map-time-slider">
          <div class="map-time-label" id="mapTimeLabel" style="font-weight:700;text-decoration:underline;font-size:13px;margin-bottom:4px;">Latest</div>
          <input type="range" id="mapTimeSlider" min="0" max="100" value="100">
          <div id="mapTimeTicks" style="display:flex;justify-content:space-between;position:relative;height:14px;"></div>
        </div>
        <div id="mapDeltaControls" style="display:none;" class="map-delta-range">
          <div style="flex:1;">
            <div class="map-time-label" id="mapDeltaSelectedLabel" style="font-weight:700;text-decoration:underline;font-size:13px;margin-bottom:4px;">Full range</div>
            <div style="display:flex;gap:8px;align-items:center;">
              <span style="font-size:11px;color:var(--text-muted);font-weight:600;">From</span>
              <input type="range" id="mapDeltaStart" min="0" max="100" value="0" style="flex:1;">
              <span style="font-size:11px;color:var(--text-muted);font-weight:600;">To</span>
              <input type="range" id="mapDeltaEnd" min="0" max="100" value="100" style="flex:1;">
            </div>
            <div id="mapDeltaTicks" style="display:flex;justify-content:space-between;position:relative;height:14px;"></div>
          </div>
        </div>
      </div>
      <div id="mapContainer"></div>
      <details style="margin-top:12px;">
        <summary style="cursor:pointer;font-size:12px;color:var(--text-muted);">Show data table</summary>
        <div style="overflow-x:auto;margin-top:8px;">
          <table class="heatmap-table" id="heatmapTable"></table>
        </div>
      </details>
    </div>

    <!-- Stats row -->
    <div class="stats-row" id="statsRow"></div>
    <div class="excluded-info" id="excludedInfo"></div>

    <!-- Quick Views -->
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px;">
      <button id="qvMacMini" class="view-tab" style="background:var(--input-bg);border-color:#0a84ff;color:#6cb4ff;padding:8px 16px;">üñ• Base Mac Mini ‚Äî by City</button>
      <button id="qvAllProducts" class="view-tab" style="background:var(--input-bg);border-color:#30d158;color:#30d158;padding:8px 16px;">üìä All Products ‚Äî Over Time</button>
    </div>

    <!-- Main chart area -->
    <div class="chart-card">
      <h3 id="mainChartTitle">Availability Over Time</h3>
      <div class="chart-container">
        <canvas id="mainChart"></canvas>
      </div>
    </div>

    <!-- City summary -->
    <div class="chart-card">
      <h3>City Averages</h3>
      <div class="summary-grid" id="citySummary"></div>
    </div>

    <!-- City moves -->
    <div class="chart-card">
      <h3>Largest Moves by City</h3>
      <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap;margin-bottom:12px;">
        <div class="period-btns" id="moverPeriodBtns">
          <button class="period-btn active" data-hours="24">24h</button>
          <button class="period-btn" data-hours="168">7d</button>
          <button class="period-btn" data-hours="336">2wk</button>
        </div>
        <div style="display:flex;align-items:center;gap:6px;">
          <span style="color:var(--text-muted);font-size:12px;">or last</span>
          <input type="number" id="moverUpdatesInput" min="1" max="500" placeholder="N" style="width:60px;background:var(--input-bg);color:var(--text);border:1px solid var(--input-border);padding:6px 8px;border-radius:6px;font-size:13px;text-align:center;">
          <span style="color:var(--text-muted);font-size:12px;">updates</span>
          <button id="moverUpdatesBtn" class="period-btn" style="margin-left:4px;">Go</button>
        </div>
      </div>
      <div class="summary-grid" id="moversGrid"></div>
    </div>

    <!-- Per-product chart -->
    <div class="chart-card">
      <h3 id="productChartTitle">Product Comparison</h3>
      <div class="chart-container">
        <canvas id="productChart"></canvas>
      </div>
    </div>

    <!-- Data matrix (shown when a specific product is selected) -->
    <div class="chart-card" id="dataMatrixCard" style="display:none;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;">
        <h3 id="dataMatrixTitle" style="margin-bottom:0;">Data Matrix</h3>
        <button id="downloadCsv" class="secondary" style="font-size:12px;padding:6px 14px;">Download CSV</button>
      </div>
      <div style="overflow-x:auto;max-height:500px;overflow-y:auto;">
        <table class="heatmap-table" id="dataMatrixTable"></table>
      </div>
    </div>
  </div>

  <script>
    let DATA = null;
    let mainChart = null;
    let productChart = null;
    let currentView = 'trends';
    let timeMin = 0;  // epoch ms ‚Äî absolute min from data
    let timeMax = 0;  // epoch ms ‚Äî absolute max from data
    let timeStartMs = 0; // current selected start
    let timeEndMs = 0;   // current selected end

    // === Map state ===
    let leafletMap = null;
    let voronoiLayer = null;
    let mapTileLayer = null;
    let mapTooltipEl = null;

    const CITY_COLORS = {
      'NYC': '#ff6384', 'LA': '#36a2eb', 'SF': '#ffce56', 'Austin': '#4bc0c0',
      'Boston': '#9966ff', 'Chicago': '#ff9f40', 'Houston': '#c9cbcf',
      'Phoenix': '#7bc8a4', 'Seattle': '#f67019', 'Miami': '#00d2ff',
      'Denver': '#e8c3b9', 'Atlanta': '#c45850'
    };

    const PRODUCT_COLORS = [
      '#0a84ff', '#30d158', '#ff9f0a', '#ff453a', '#bf5af2',
      '#64d2ff', '#ffd60a', '#ff375f', '#ac8e68', '#8e8e93',
      '#5e5ce6', '#ff6482', '#32d74b', '#ffcc02', '#eb4d3d'
    ];

    /**
     * Click-to-highlight: clicking a line dims all others.
     * Clicking the background resets.
     */
    function makeHighlightPlugin(chartRef) {
      return {
        id: 'clickHighlight',
        _highlighted: -1,
        _hovered: -1,
        _origStyles: [],
        afterEvent(chart, args) {
          const evt = args.event;

          // --- Click: select/deselect a line ---
          if (evt.type === 'click') {
            // Ignore clicks outside the chart area (e.g. legend clicks)
            const area = chart.chartArea;
            if (!area || evt.x < area.left || evt.x > area.right || evt.y < area.top || evt.y > area.bottom) {
              return; // Let the legend onClick handler deal with it
            }
            // Use 'dataset' mode with intersect:false so clicking near a line works
            const elements = chart.getElementsAtEventForMode(evt, 'dataset', { intersect: false }, false);
            if (elements.length > 0) {
              const clickedIdx = elements[0].datasetIndex;
              this._highlight(chart, clickedIdx);
            } else {
              this._reset(chart);
            }
            return;
          }

          // --- Mousemove: subtle hover highlight on nearest line ---
          if (evt.type === 'mousemove') {
            const elements = chart.getElementsAtEventForMode(evt, 'dataset', { intersect: false }, false);
            const hoverIdx = elements.length > 0 ? elements[0].datasetIndex : -1;
            if (hoverIdx !== this._hovered) {
              this._hovered = hoverIdx;
              this._applyHover(chart);
            }
            return;
          }

          // --- Mouseout: clear hover ---
          if (evt.type === 'mouseout') {
            if (this._hovered !== -1) {
              this._hovered = -1;
              this._applyHover(chart);
            }
          }
        },
        _dimColor(color) {
          if (typeof color !== 'string') return color;
          if (/^#[0-9a-f]{6}$/i.test(color)) return color + '26';
          if (/^#[0-9a-f]{8}$/i.test(color)) return color.slice(0, 7) + '26';
          if (color.startsWith('rgb')) return color.replace(/[\d.]+\)$/, '0.15)');
          return color;
        },
        /** Apply subtle hover effect (only when nothing is click-highlighted) */
        _applyHover(chart) {
          // Don't interfere with click-highlight state
          if (this._highlighted >= 0) {
            // When highlighted, just update cursor
            chart.canvas.style.cursor = this._hovered >= 0 ? 'pointer' : 'default';
            chart.update('none');
            return;
          }
          this._ensureOrigStyles(chart);
          chart.data.datasets.forEach((ds, i) => {
            if (this._hovered === -1) {
              // No hover ‚Äî restore originals
              ds.borderColor = this._origStyles[i].borderColor;
              ds.borderWidth = this._origStyles[i].borderWidth;
              ds.pointRadius = this._origStyles[i].pointRadius;
            } else if (i === this._hovered) {
              // Hovered line: slightly thicker
              ds.borderColor = this._origStyles[i].borderColor;
              ds.borderWidth = this._origStyles[i].borderWidth + 1.5;
              ds.pointRadius = this._origStyles[i].pointRadius;
            } else {
              // Other lines: stay normal
              ds.borderColor = this._origStyles[i].borderColor;
              ds.borderWidth = this._origStyles[i].borderWidth;
              ds.pointRadius = this._origStyles[i].pointRadius;
            }
          });
          chart.canvas.style.cursor = this._hovered >= 0 ? 'pointer' : 'default';
          if (this._hovered === -1) {
            // Clean up origStyles so _highlight can re-capture fresh state
            this._origStyles = [];
          }
          chart.update('none');
        },
        _ensureOrigStyles(chart) {
          if (this._origStyles.length === 0) {
            this._origStyles = chart.data.datasets.map(ds => ({
              borderColor: ds.borderColor,
              borderWidth: ds.borderWidth,
              pointRadius: ds.pointRadius,
              borderDash: ds.borderDash || [],
            }));
          }
        },
        _highlight(chart, idx) {
          if (this._highlighted === idx) {
            this._reset(chart);
            return;
          }
          this._ensureOrigStyles(chart);
          chart.data.datasets.forEach((ds, i) => {
            // Never dim eBay price datasets (y2 axis)
            if (ds.yAxisID === 'y2') return;
            if (i === idx) {
              ds.borderColor = this._origStyles[i].borderColor;
              ds.borderWidth = 3;
              ds.pointRadius = 4;
              ds.borderDash = [];
            } else {
              ds.borderColor = this._dimColor(this._origStyles[i].borderColor);
              ds.borderWidth = 1;
              ds.pointRadius = 0;
              ds.borderDash = [];
            }
          });
          this._highlighted = idx;
          chart.canvas.style.cursor = 'pointer';
          chart.update('none');
        },
        _reset(chart) {
          if (this._origStyles.length === 0) return;
          chart.data.datasets.forEach((ds, i) => {
            ds.borderColor = this._origStyles[i].borderColor;
            ds.borderWidth = this._origStyles[i].borderWidth;
            ds.pointRadius = this._origStyles[i].pointRadius;
            ds.borderDash = this._origStyles[i].borderDash;
          });
          this._origStyles = [];
          this._highlighted = -1;
          this._hovered = -1;
          chart.canvas.style.cursor = 'default';
          chart.update('none');
        }
      };
    }

    async function loadData() {
      const resp = await fetch('data.json');
      DATA = await resp.json();

      // Show last-updated time from most recent snapshot
      if (DATA.snapshots && DATA.snapshots.length > 0) {
        const last = new Date(DATA.snapshots[DATA.snapshots.length - 1].timestamp);
        const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const h = last.getHours(), m = last.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        const h12 = h % 12 || 12;
        const minStr = m < 10 ? '0' + m : m;
        document.getElementById('lastUpdated').textContent =
          `Last updated ${days[last.getDay()]} ${months[last.getMonth()]} ${last.getDate()} at ${h12}:${minStr} ${ampm}`;
      }

      // Show website build time in header top-right
      if (DATA.generated_at) {
        const gen = new Date(DATA.generated_at);
        const days = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const h = gen.getHours(), m = gen.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        const h12 = h % 12 || 12;
        const minStr = m < 10 ? '0' + m : m;
        document.getElementById('lastUpdatedSite').textContent =
          `Site built ${months[gen.getMonth()]} ${gen.getDate()} at ${h12}:${minStr} ${ampm}`;
      }

      initControls();
      render();
      document.getElementById('loading').style.display = 'none';
      document.getElementById('dashboard').style.display = 'flex';
    }

    function updateEbaySubToggles() {
      const ebayOn = document.getElementById('showEbayPrices').checked;
      document.querySelectorAll('.ebay-sub-toggle').forEach(el => {
        el.style.opacity = ebayOn ? '1' : '0.4';
        el.style.pointerEvents = ebayOn ? 'auto' : 'none';
      });
    }

    function initControls() {
      const productSelect = document.getElementById('productSelect');
      // Add "All Products (Average)" option
      const allOpt = document.createElement('option');
      allOpt.value = '__ALL__';
      allOpt.textContent = 'All Products (Average)';
      productSelect.appendChild(allOpt);

      // Only include models that have data in recent snapshots (last 10)
      const recentSnapshots = DATA.snapshots.slice(-10);
      const modelsWithData = DATA.all_models.filter(model => {
        return recentSnapshots.some(s => {
          const prod = s.products.find(p => p.model === model);
          if (!prod) return false;
          return Object.values(prod.values).some(v => v !== null && v !== undefined);
        });
      });

      modelsWithData.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m;
        opt.textContent = m;
        productSelect.appendChild(opt);
      });

      // Default to Mac Mini M4 ($599) on load
      const defaultProduct = modelsWithData.find(m => m === 'Mac Mini M4 ($599)');
      if (defaultProduct) productSelect.value = defaultProduct;

      const citySelect = document.getElementById('citySelect');
      DATA.all_cities.forEach(c => {
        const opt = document.createElement('option');
        opt.value = c;
        opt.textContent = c;
        opt.selected = true;
        citySelect.appendChild(opt);
      });

      productSelect.addEventListener('change', render);
      citySelect.addEventListener('change', render);
      document.getElementById('filterZeros').addEventListener('change', render);
      document.getElementById('showAvailability').addEventListener('change', render);
      document.getElementById('showEbayPrices').addEventListener('change', () => {
        updateEbaySubToggles();
        render();
      });
      document.getElementById('showEbayMean').addEventListener('change', render);
      document.getElementById('showEbayMedian').addEventListener('change', render);
      document.getElementById('customAvgInput').addEventListener('input', render);

      // Show eBay toggles only if data is available
      if (DATA.ebay_prices && DATA.ebay_prices.products.length > 0) {
        document.getElementById('ebayToggleLabel').style.display = 'flex';
        document.getElementById('ebayMeanLabel').style.display = 'flex';
        document.getElementById('ebayMedianLabel').style.display = 'flex';
      }

      document.getElementById('resetCities').addEventListener('click', () => {
        [...citySelect.options].forEach(o => o.selected = true);
        render();
      });

      document.getElementById('selectAllCities').addEventListener('click', () => {
        [...citySelect.options].forEach(o => o.selected = true);
        render();
      });

      document.getElementById('clearCities').addEventListener('click', () => {
        [...citySelect.options].forEach(o => o.selected = false);
        render();
      });

      document.querySelectorAll('.view-tab').forEach(tab => {
        tab.addEventListener('click', () => {
          document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          currentView = tab.dataset.view;
          render();
        });
      });

      // Quick view buttons
      document.getElementById('qvMacMini').addEventListener('click', () => {
        // Set product to Mac Mini M4 ($599), view to Trends
        const ps = document.getElementById('productSelect');
        const macMini = [...ps.options].find(o => o.value === 'Mac Mini M4 ($599)');
        if (macMini) ps.value = macMini.value;
        document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
        const trendsTab = document.querySelector('.view-tab[data-view="trends"]');
        if (trendsTab) { trendsTab.classList.add('active'); currentView = 'trends'; }
        render();
      });

      document.getElementById('qvAllProducts').addEventListener('click', () => {
        // Set product to All Products, view to Trends
        document.getElementById('productSelect').value = '__ALL__';
        document.querySelectorAll('.view-tab').forEach(t => t.classList.remove('active'));
        const trendsTab = document.querySelector('.view-tab[data-view="trends"]');
        if (trendsTab) { trendsTab.classList.add('active'); currentView = 'trends'; }
        render();
      });

      // Mover period buttons
      document.querySelectorAll('#moverPeriodBtns .period-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.classList.contains('disabled')) return;
          document.querySelectorAll('#moverPeriodBtns .period-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          _moverPeriodHours = parseInt(btn.dataset.hours);
          _moverUpdatesCount = null; // Switch back to hours mode
          document.getElementById('moverUpdatesInput').value = '';
          render();
        });
      });

      // Mover "last N updates" button
      document.getElementById('moverUpdatesBtn').addEventListener('click', () => {
        const input = document.getElementById('moverUpdatesInput');
        const val = parseInt(input.value);
        if (val && val > 0) {
          _moverUpdatesCount = val;
          document.querySelectorAll('#moverPeriodBtns .period-btn').forEach(b => b.classList.remove('active'));
          render();
        }
      });
      document.getElementById('moverUpdatesInput').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          document.getElementById('moverUpdatesBtn').click();
        }
      });

      // Time range controls
      initTimeRange();
    }

    function toLocalDatetimeStr(ms) {
      const d = new Date(ms);
      const pad = (n, len=2) => String(n).padStart(len, '0');
      return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())}T${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }

    function fromLocalDatetimeStr(str) {
      return new Date(str).getTime();
    }

    // Global time range sync functions
    function updateTrackFill() {
      const pctL = ((timeStartMs - timeMin) / (timeMax - timeMin)) * 100;
      const pctR = ((timeEndMs - timeMin) / (timeMax - timeMin)) * 100;
      const fill = document.getElementById('trackFill');
      fill.style.left = pctL + '%';
      fill.style.width = (pctR - pctL) + '%';
    }

    function syncSlidersFromMs() {
      const rangeStart = document.getElementById('rangeStart');
      const rangeEnd = document.getElementById('rangeEnd');
      rangeStart.value = Math.round(((timeStartMs - timeMin) / (timeMax - timeMin)) * 1000);
      rangeEnd.value = Math.round(((timeEndMs - timeMin) / (timeMax - timeMin)) * 1000);
      updateTrackFill();
    }

    function syncInputsFromMs() {
      document.getElementById('timeStart').value = toLocalDatetimeStr(timeStartMs);
      document.getElementById('timeEnd').value = toLocalDatetimeStr(timeEndMs);
    }

    function setTimeRangeToLastNUpdates(n) {
      if (!DATA || !DATA.snapshots || DATA.snapshots.length < 2) return;
      const snapshots = DATA.snapshots;
      const startIdx = Math.max(0, snapshots.length - n);
      timeStartMs = new Date(snapshots[startIdx].timestamp).getTime();
      timeEndMs = new Date(snapshots[snapshots.length - 1].timestamp).getTime();
      syncInputsFromMs();
      syncSlidersFromMs();
    }

    function initTimeRange() {
      const timestamps = DATA.snapshots.map(s => new Date(s.timestamp).getTime());
      timeMin = Math.min(...timestamps);
      timeMax = Math.max(...timestamps);
      timeStartMs = timeMin;
      timeEndMs = timeMax;

      const startInput = document.getElementById('timeStart');
      const endInput = document.getElementById('timeEnd');
      const rangeStart = document.getElementById('rangeStart');
      const rangeEnd = document.getElementById('rangeEnd');
      const resetBtn = document.getElementById('timeReset');

      startInput.value = toLocalDatetimeStr(timeMin);
      endInput.value = toLocalDatetimeStr(timeMax);

      function clearPeriodBtnActive() {
        document.querySelectorAll('#timeRangePeriodBtns .period-btn').forEach(b => b.classList.remove('active'));
      }

      // Slider -> update text + render
      rangeStart.addEventListener('input', () => {
        let val = parseInt(rangeStart.value);
        const endVal = parseInt(rangeEnd.value);
        if (val > endVal) { val = endVal; rangeStart.value = val; }
        timeStartMs = timeMin + (val / 1000) * (timeMax - timeMin);
        syncInputsFromMs();
        updateTrackFill();
        clearPeriodBtnActive();
        render();
      });

      rangeEnd.addEventListener('input', () => {
        let val = parseInt(rangeEnd.value);
        const startVal = parseInt(rangeStart.value);
        if (val < startVal) { val = startVal; rangeEnd.value = val; }
        timeEndMs = timeMin + (val / 1000) * (timeMax - timeMin);
        syncInputsFromMs();
        updateTrackFill();
        clearPeriodBtnActive();
        render();
      });

      // Text input -> update slider + render
      startInput.addEventListener('change', () => {
        const ms = fromLocalDatetimeStr(startInput.value);
        if (!isNaN(ms)) {
          timeStartMs = Math.max(timeMin, Math.min(ms, timeEndMs));
          syncInputsFromMs();
          syncSlidersFromMs();
          clearPeriodBtnActive();
          render();
        }
      });

      endInput.addEventListener('change', () => {
        const ms = fromLocalDatetimeStr(endInput.value);
        if (!isNaN(ms)) {
          timeEndMs = Math.min(timeMax, Math.max(ms, timeStartMs));
          syncInputsFromMs();
          syncSlidersFromMs();
          clearPeriodBtnActive();
          render();
        }
      });

      // Reset button
      resetBtn.addEventListener('click', () => {
        timeStartMs = timeMin;
        timeEndMs = timeMax;
        syncInputsFromMs();
        syncSlidersFromMs();
        // Activate "Max" button
        document.querySelectorAll('#timeRangePeriodBtns .period-btn').forEach(b => b.classList.remove('active'));
        document.querySelector('#timeRangePeriodBtns .period-btn[data-hours="0"]').classList.add('active');
        render();
      });

      // Time range period buttons (24h, 7d, 2wk, Max)
      // Grey out buttons whose period exceeds total data range (same 50% threshold as section buttons)
      const dataRangeHours = (timeMax - timeMin) / 3600000;
      document.querySelectorAll('#timeRangePeriodBtns .period-btn').forEach(btn => {
        const hours = parseInt(btn.dataset.hours);
        if (hours > 0 && dataRangeHours < hours * 0.5) {
          btn.classList.add('disabled');
        }
      });

      document.querySelectorAll('#timeRangePeriodBtns .period-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (btn.classList.contains('disabled')) return;
          const hours = parseInt(btn.dataset.hours);
          document.querySelectorAll('#timeRangePeriodBtns .period-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          if (hours === 0) {
            timeStartMs = timeMin;
          } else {
            timeStartMs = Math.max(timeMin, timeMax - hours * 3600000);
          }
          timeEndMs = timeMax;
          syncInputsFromMs();
          syncSlidersFromMs();
          render();
        });
      });

      syncSlidersFromMs();
      updateTrackFill();
    }

    function _baseFilteredSnapshots() {
      return DATA.snapshots.filter(s => {
        // Always exclude qty/3-item files
        if (s.file_type === 'qty' || s.file_type === '3_item') return false;
        // Always exclude snapshots where all cities have store_count = 0
        const allZeroStores = s.cities.every(c => c.store_count === 0);
        if (allZeroStores) return false;
        return true;
      });
    }

    function getFilteredSnapshots() {
      const filterZeros = document.getElementById('filterZeros').checked;
      let snapshots = _baseFilteredSnapshots().filter(s => {
        const ts = new Date(s.timestamp).getTime();
        if (ts < timeStartMs || ts > timeEndMs) return false;
        return true;
      });
      return { snapshots, filterZeros };
    }

    /** All quality-filtered snapshots, ignoring the time range slider.
     *  Used by City Averages & Movers so they can compute their own periods independently. */
    function getAllSnapshots() {
      const filterZeros = document.getElementById('filterZeros').checked;
      return { snapshots: _baseFilteredSnapshots(), filterZeros };
    }

    function getSelectedCities() {
      const sel = document.getElementById('citySelect');
      return [...sel.selectedOptions].map(o => o.value);
    }

    function getSelectedProduct() {
      return document.getElementById('productSelect').value;
    }

    function getCustomAvgCities() {
      const raw = document.getElementById('customAvgInput').value.trim();
      if (!raw) return [];
      const allCities = DATA.all_cities.map(c => c.toLowerCase());
      return raw.split(',')
        .map(s => s.trim())
        .filter(s => s.length > 0)
        .map(s => {
          // Match case-insensitively against known cities
          const idx = allCities.indexOf(s.toLowerCase());
          return idx >= 0 ? DATA.all_cities[idx] : null;
        })
        .filter(c => c !== null);
    }

    /**
     * Build a set of (product, city, snapshotIndex) triples where a 0% value
     * is a blip ‚Äî i.e. the nearest non-null neighbors on BOTH sides are much
     * higher. This handles gaps/skips in the data.
     *
     * A 0% at index i is a blip if:
     *   - The closest non-null, non-zero value BEFORE i is >= BLIP_THRESHOLD
     *   - The closest non-null, non-zero value AFTER  i is >= BLIP_THRESHOLD
     *   - OR it's at the edge (first/last) and the one available neighbor is >= BLIP_THRESHOLD
     *   - OR the store count for that city in that snapshot is 0
     */
    const BLIP_THRESHOLD = 25; // neighbor must be >= this % to call a 0% a blip
    let _blipSet = null;
    let _blipSetKey = null;

    function getBlipSet(snapshots) {
      const key = snapshots.length + '|' + (snapshots.length > 0 ? snapshots[0].timestamp : '');
      if (_blipSetKey === key && _blipSet) return _blipSet;

      const blips = new Set();

      // Collect all unique (product, city) pairs
      const pairs = new Map(); // key -> [{idx, val, storeCount}]
      snapshots.forEach((s, si) => {
        s.products.forEach(p => {
          s.cities.forEach(cityInfo => {
            const city = cityInfo.name;
            const val = p.values[city];
            if (val === null || val === undefined) return;
            const k = `${p.model}|||${city}`;
            if (!pairs.has(k)) pairs.set(k, []);
            pairs.get(k).push({ si, val, storeCount: cityInfo.store_count });
          });
        });
      });

      // For each (product, city), walk the time-ordered sequence
      pairs.forEach((entries, key) => {
        // entries are already in snapshot order since we iterated snapshots in order
        for (let i = 0; i < entries.length; i++) {
          const e = entries[i];
          if (e.val !== 0) continue;

          // Always flag 0% when store count is 0
          if (e.storeCount <= 0) {
            blips.add(`${key}|||${e.si}`);
            continue;
          }

          // Find nearest non-null neighbor BEFORE with val > 0
          let prevVal = null;
          for (let j = i - 1; j >= 0; j--) {
            if (entries[j].val !== null && entries[j].val > 0) {
              prevVal = entries[j].val;
              break;
            }
          }

          // Find nearest non-null neighbor AFTER with val > 0
          let nextVal = null;
          for (let j = i + 1; j < entries.length; j++) {
            if (entries[j].val !== null && entries[j].val > 0) {
              nextVal = entries[j].val;
              break;
            }
          }

          // Determine if it's a blip:
          // - Both neighbors exist and are >= threshold
          // - Or only one neighbor exists (edge) and it's >= threshold
          // - Or no neighbors (all zeros) ‚Äî keep it as real data
          const prevHigh = prevVal !== null && prevVal >= BLIP_THRESHOLD;
          const nextHigh = nextVal !== null && nextVal >= BLIP_THRESHOLD;
          const hasNeighbors = prevVal !== null || nextVal !== null;

          if (hasNeighbors && (prevVal === null || prevHigh) && (nextVal === null || nextHigh)) {
            blips.add(`${key}|||${e.si}`);
          }
        }
      });

      _blipSet = blips;
      _blipSetKey = key;
      return blips;
    }

    /**
     * For a given snapshot, product, and city, determine if the data point is valid.
     * Filters out: null/ERR, store count 0, and 0% blips (isolated drops surrounded
     * by much higher values).
     */
    function getValidValue(snapshot, product, cityName, filterZeros, blipSet, snapshotIdx) {
      const prodData = snapshot.products.find(p => p.model === product);
      if (!prodData) return null;
      const val = prodData.values[cityName];
      if (val === null || val === undefined) return null;

      const cityInfo = snapshot.cities.find(c => c.name === cityName);
      // If store count is 0 or unknown, it's likely an error snapshot for this city
      if (cityInfo && cityInfo.store_count === 0) return null;

      if (filterZeros && val === 0 && blipSet) {
        const k = `${product}|||${cityName}|||${snapshotIdx}`;
        if (blipSet.has(k)) return null;
      }

      return val;
    }

    function render() {
      const { snapshots, filterZeros } = getFilteredSnapshots();
      const selectedCities = getSelectedCities();
      const selectedProduct = getSelectedProduct();
      const isAllProducts = selectedProduct === '__ALL__';
      const blipSet = filterZeros ? getBlipSet(snapshots) : null;

      // Toggle heatmap-view class for control hiding
      if (currentView === 'heatmap') {
        document.body.classList.add('heatmap-view');
      } else {
        document.body.classList.remove('heatmap-view');
      }

      updateStats(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet);

      if (currentView === 'trends' || currentView === 'compare') {
        document.getElementById('heatmapCard').style.display = 'none';
        renderTrendsChart(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet);
      } else {
        document.getElementById('heatmapCard').style.display = 'block';
        renderHeatmap(snapshots, selectedCities, filterZeros, blipSet);
        renderTrendsChart(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet);
        // Initialize & update map
        if (DATA && DATA.store_map) {
          setTimeout(() => {
            initMap();
            updateMapOverlay();
          }, 50);
        }
      }

      // City Averages now uses the same time-filtered snapshots as the main chart.
      // Movers still uses ALL snapshots so its period buttons are independent.
      renderCitySummary(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet);
      const allSnaps = getAllSnapshots();
      const allBlipSet = allSnaps.filterZeros ? getBlipSet(allSnaps.snapshots) : null;
      renderMovers(allSnaps.snapshots, selectedCities, allSnaps.filterZeros, isAllProducts, selectedProduct, allBlipSet);
      renderProductChart(snapshots, selectedCities, filterZeros, blipSet);
      renderDataMatrix(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet);
    }

    function updateStats(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet) {
      const statsRow = document.getElementById('statsRow');
      const excludedInfo = document.getElementById('excludedInfo');

      let totalPoints = 0;
      let excludedPoints = 0;
      let validValues = [];

      snapshots.forEach((s, si) => {
        const products = isAllProducts ? s.products.map(p => p.model) : [selectedProduct];
        products.forEach(prod => {
          selectedCities.forEach(city => {
            totalPoints++;
            const val = getValidValue(s, prod, city, filterZeros, blipSet, si);
            if (val !== null) {
              validValues.push(val);
            } else {
              excludedPoints++;
            }
          });
        });
      });

      const avg = validValues.length ? (validValues.reduce((a, b) => a + b, 0) / validValues.length).toFixed(1) : 'N/A';
      const min = validValues.length ? Math.min(...validValues) : 'N/A';
      const max = validValues.length ? Math.max(...validValues) : 'N/A';

      statsRow.innerHTML = `
        <div class="stat-box">
          <div class="stat-label">Snapshots</div>
          <div class="stat-value">${snapshots.length}</div>
        </div>
        <div class="stat-box">
          <div class="stat-label">Data Points</div>
          <div class="stat-value">${validValues.length}</div>
        </div>
      `;

      excludedInfo.textContent = excludedPoints > 0
        ? `${excludedPoints} data points excluded by filters (ERR, N/A, error snapshots with 0 stores, or isolated single-call 0% values)`
        : '';
    }

    function renderTrendsChart(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet) {
      const ctx = document.getElementById('mainChart');

      if (mainChart) {
        mainChart.destroy();
        mainChart = null;
      }

      let datasets = [];
      const showAvailability = document.getElementById('showAvailability').checked;

      /** Helper: get store count for a city in a snapshot */
      function getStoreCount(snapshot, cityName) {
        const c = snapshot.cities.find(c => c.name === cityName);
        return (c && c.store_count > 0) ? c.store_count : 0;
      }

      /** Helper: compute store-weighted average across cities for a snapshot.
       *  products is an array of product names to average over.
       *  Returns null if no valid data. */
      function weightedAvg(snapshot, si, products, cities, filterZeros, blipSet) {
        let totalWeight = 0, weightedSum = 0;
        const totalPossible = cities.length * products.length;
        let validCount = 0;
        cities.forEach(city => {
          const sc = getStoreCount(snapshot, city);
          if (sc <= 0) return;
          products.forEach(prod => {
            const val = getValidValue(snapshot, prod, city, filterZeros, blipSet, si);
            if (val !== null) {
              weightedSum += val * sc;
              totalWeight += sc;
              validCount++;
            }
          });
        });
        // Require at least 2/3 of data points to be non-error
        if (totalWeight <= 0 || validCount < totalPossible * (2 / 3)) return null;
        return weightedSum / totalWeight;
      }

      if (showAvailability && (currentView === 'compare' || !isAllProducts)) {
        // One line per city
        const title = isAllProducts ? 'Average Availability by City' : `${selectedProduct} ‚Äî Availability by City`;
        document.getElementById('mainChartTitle').textContent = title;

        selectedCities.forEach(city => {
          // First pass: collect raw values (null where missing)
          const rawPoints = snapshots.map((s, si) => {
            let val = null;
            if (isAllProducts) {
              const vals = s.products
                .map(p => getValidValue(s, p.model, city, filterZeros, blipSet, si))
                .filter(v => v !== null);
              if (vals.length > 0) {
                val = vals.reduce((a, b) => a + b, 0) / vals.length;
              }
            } else {
              val = getValidValue(s, selectedProduct, city, filterZeros, blipSet, si);
            }
            return { x: new Date(s.timestamp), y: val };
          });

          // Only keep points with actual data ‚Äî no interpolation
          const points = rawPoints
            .filter(pt => pt.y !== null)
            .map(pt => ({ x: pt.x, y: pt.y, estimated: false }));

          if (points.length > 0) {
            datasets.push({
              label: city,
              data: points,
              borderColor: CITY_COLORS[city] || '#888',
              backgroundColor: (CITY_COLORS[city] || '#888') + '20',
              borderWidth: 2,
              pointRadius: 3,
              pointHoverRadius: 5,
              tension: 0.3,
              fill: false
            });
          }
        });

        // Add weighted average line (weighted by store count per city)
        if (selectedCities.length > 1) {
          const avgPoints = [];
          const products = isAllProducts ? DATA.all_models : [selectedProduct];
          snapshots.forEach((s, si) => {
            const val = weightedAvg(s, si, products, selectedCities, filterZeros, blipSet);
            if (val !== null) {
              avgPoints.push({ x: new Date(s.timestamp), y: val });
            }
          });
          if (avgPoints.length > 0) {
            const isLight = document.documentElement.getAttribute('data-theme') === 'light';
            const avgColor = isLight ? '#1d1d1f' : '#ffffff';
            datasets.push({
              label: 'Weighted Avg',
              data: avgPoints,
              borderColor: avgColor,
              backgroundColor: avgColor + '20',
              borderWidth: 3,
              borderDash: [6, 3],
              pointRadius: 0,
              pointHoverRadius: 5,
              tension: 0.3,
              fill: false
            });
          }
        }

        // Add custom weighted average line if user specified cities
        const customCities = getCustomAvgCities();
        if (customCities.length > 0) {
          const customPoints = [];
          const products = isAllProducts ? DATA.all_models : [selectedProduct];
          snapshots.forEach((s, si) => {
            const val = weightedAvg(s, si, products, customCities, filterZeros, blipSet);
            if (val !== null) {
              customPoints.push({ x: new Date(s.timestamp), y: val });
            }
          });
          if (customPoints.length > 0) {
            datasets.push({
              label: 'Custom Avg (' + customCities.join(', ') + ')',
              data: customPoints,
              borderColor: '#ffd60a',
              backgroundColor: '#ffd60a20',
              borderWidth: 3,
              borderDash: [3, 3],
              pointRadius: 0,
              pointHoverRadius: 5,
              tension: 0.3,
              fill: false
            });
          }
        }
      } else if (showAvailability) {
        // All products view: one line per product (store-weighted average across selected cities)
        document.getElementById('mainChartTitle').textContent = 'All Products ‚Äî Store-Weighted Average Across Selected Cities';

        // First pass: compute each product's overall weighted avg for sorting
        const modelStats = DATA.all_models.map((model, idx) => {
          const points = [];
          let overallSum = 0, overallWeight = 0;
          snapshots.forEach((s, si) => {
            let wSum = 0, wTotal = 0;
            let validCount = 0;
            const totalPossible = selectedCities.length;
            selectedCities.forEach(city => {
              const sc = getStoreCount(s, city);
              if (sc <= 0) return;
              const val = getValidValue(s, model, city, filterZeros, blipSet, si);
              if (val !== null) {
                wSum += val * sc;
                wTotal += sc;
                validCount++;
              }
            });
            // Only include point if more than 2/3 of cities are reporting
            if (wTotal > 0 && validCount >= totalPossible * (2 / 3)) {
              const avg = wSum / wTotal;
              points.push({ x: new Date(s.timestamp), y: avg });
              overallSum += avg;
              overallWeight++;
            }
          });
          return { model, idx, points, overallAvg: overallWeight > 0 ? overallSum / overallWeight : -1 };
        }).filter(m => m.points.length > 0);

        // Sort by overall weighted average (lowest first so worst products are easy to spot)
        modelStats.sort((a, b) => a.overallAvg - b.overallAvg);

        modelStats.forEach((m, sortIdx) => {
          datasets.push({
            label: `${m.model} (${m.overallAvg.toFixed(0)}%)`,
            data: m.points,
            borderColor: PRODUCT_COLORS[sortIdx % PRODUCT_COLORS.length],
            borderWidth: 2,
            pointRadius: 2,
            pointHoverRadius: 5,
            tension: 0.3,
            fill: false
          });
        });
      }

      if (!showAvailability) {
        document.getElementById('mainChartTitle').textContent = isAllProducts
          ? 'eBay Prices ‚Äî All Products'
          : `${selectedProduct} ‚Äî eBay Prices`;
      }

      // --- eBay price overlay ---
      const showEbay = document.getElementById('showEbayPrices').checked && DATA.ebay_prices;
      const showMean = document.getElementById('showEbayMean').checked;
      const showMedian = document.getElementById('showEbayMedian').checked;
      if (showEbay) {
        const ebayData = DATA.ebay_prices.data;
        if (!isAllProducts) {
          // Single product: look for matching eBay product
          const ebayHistory = ebayData[selectedProduct];
          if (ebayHistory && ebayHistory.length > 0) {
            if (showMean) {
              datasets.push({
                label: 'eBay Mean Price',
                data: ebayHistory.filter(d => d.avg_price !== null).map(d => ({ x: new Date(d.timestamp), y: d.avg_price })),
                borderColor: '#30d158',
                backgroundColor: '#30d15820',
                borderWidth: 2.5,
                pointRadius: 5,
                pointHoverRadius: 7,
                pointStyle: 'rectRot',
                tension: 0.3,
                fill: false,
                yAxisID: 'y2',
              });
            }
            if (showMedian) {
              datasets.push({
                label: 'eBay Median Price',
                data: ebayHistory.filter(d => d.median_price !== null).map(d => ({ x: new Date(d.timestamp), y: d.median_price })),
                borderColor: '#ff9f0a',
                backgroundColor: '#ff9f0a20',
                borderWidth: 2,
                borderDash: [6, 3],
                pointRadius: 5,
                pointHoverRadius: 7,
                pointStyle: 'triangle',
                tension: 0.3,
                fill: false,
                yAxisID: 'y2',
              });
            }
          }
        } else {
          // All products: one avg + median line per eBay product
          const ebayProducts = DATA.ebay_prices.products;
          ebayProducts.forEach((productName, idx) => {
            const history = ebayData[productName];
            if (!history || history.length === 0) return;
            const color = PRODUCT_COLORS[idx % PRODUCT_COLORS.length];
            if (showMean) {
              datasets.push({
                label: `${productName} (eBay Mean)`,
                data: history.filter(d => d.avg_price !== null).map(d => ({ x: new Date(d.timestamp), y: d.avg_price })),
                borderColor: color,
                backgroundColor: color + '20',
                borderWidth: 2,
                borderDash: [8, 4],
                pointRadius: 4,
                pointHoverRadius: 6,
                pointStyle: 'rectRot',
                tension: 0.3,
                fill: false,
                yAxisID: 'y2',
              });
            }
            if (showMedian) {
              datasets.push({
                label: `${productName} (eBay Median)`,
                data: history.filter(d => d.median_price !== null).map(d => ({ x: new Date(d.timestamp), y: d.median_price })),
                borderColor: color,
                backgroundColor: color + '20',
                borderWidth: 1.5,
                borderDash: [3, 3],
                pointRadius: 3,
                pointHoverRadius: 5,
                pointStyle: 'triangle',
                tension: 0.3,
                fill: false,
                yAxisID: 'y2',
              });
            }
          });
        }
      }

      // Compute y2 axis max from eBay data
      let y2Max = 100;
      let y2Config;
      if (showEbay) {
        const ebayYValues = datasets
          .filter(ds => ds.yAxisID === 'y2')
          .flatMap(ds => ds.data.map(pt => pt.y))
          .filter(v => v !== null && v !== undefined);
        if (ebayYValues.length > 0) {
          const rawMax = Math.max(...ebayYValues);
          y2Max = Math.ceil(rawMax / 100) * 100;
          if (y2Max < rawMax * 1.1) y2Max = Math.ceil(rawMax * 1.1 / 50) * 50;
        }
        y2Config = {
          position: 'right',
          min: 0,
          max: y2Max,
          grid: { drawOnChartArea: !showAvailability, color: getThemeColors().grid },
          ticks: { color: '#30d158', callback: v => '$' + v.toLocaleString() },
          title: { display: true, text: 'eBay Price ($)', color: '#30d158', font: { size: 12 } }
        };
      } else {
        y2Config = {
          position: 'right',
          min: 0, max: 100,
          grid: { drawOnChartArea: false },
          ticks: { color: getThemeColors().tick, callback: v => v + '%' }
        };
      }

      // Hide left y-axis when availability is off
      const yConfig = {
        position: 'left',
        min: 0, max: 100,
        display: showAvailability,
        grid: { color: getThemeColors().grid },
        ticks: { color: getThemeColors().tick, callback: v => v + '%' }
      };

      const highlightPlugin = makeHighlightPlugin('mainChart');
      mainChart = new Chart(ctx, {
        type: 'line',
        data: { datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: { mode: 'index', intersect: false },
          onClick: () => {}, // enable click events for plugin
          plugins: {
            legend: {
              position: 'top',
              labels: { color: getThemeColors().tickLabel, usePointStyle: true, pointStyle: 'circle', padding: 16 },
              onClick: (e, legendItem, legend) => {
                // Clicking a legend item highlights that dataset
                highlightPlugin._highlight(legend.chart, legendItem.datasetIndex);
              }
            },
            tooltip: {
              backgroundColor: getThemeColors().tooltipBg,
              borderColor: getThemeColors().tooltipBorder,
              borderWidth: 1,
              titleColor: document.documentElement.getAttribute('data-theme') === 'light' ? '#1d1d1f' : '#fff',
              bodyColor: document.documentElement.getAttribute('data-theme') === 'light' ? '#1d1d1f' : '#ccc',
              filter: (tooltipItem) => {
                // When a line is highlighted, only show that line's tooltip
                if (highlightPlugin._highlighted >= 0) {
                  return tooltipItem.datasetIndex === highlightPlugin._highlighted;
                }
                return true;
              },
              itemSort: (a, b) => b.parsed.y - a.parsed.y,
              callbacks: {
                label: ctx => {
                  if (ctx.dataset.yAxisID === 'y2') {
                    return `${ctx.dataset.label}: $${ctx.parsed.y.toFixed(2)}`;
                  }
                  return `${ctx.dataset.label}: ${ctx.parsed.y.toFixed(1)}%`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'time',
              max: showAvailability ? new Date() : undefined,
              time: { tooltipFormat: 'MMM d, yyyy h:mm a', displayFormats: { hour: 'h a', day: 'MMM d' } },
              grid: { color: getThemeColors().grid },
              ticks: {
                color: getThemeColors().tick,
                maxRotation: 0,
                autoSkip: true,
                major: { enabled: true },
                callback: function(value, index, ticks) {
                  const raw = ticks[index] ? ticks[index].value : value;
                  const d = new Date(raw);
                  if (isNaN(d.getTime())) return value;

                  const hour = d.getHours();
                  const min = d.getMinutes();
                  const ampm = hour >= 12 ? 'PM' : 'AM';
                  const h12 = hour % 12 || 12;
                  const minStr = min < 10 ? '0' + min : min;

                  // Detect if chart is in minute mode (sub-hour range)
                  const xScale = this.chart ? this.chart.options.scales.x : null;
                  const isMinuteMode = xScale && xScale.time && xScale.time.unit === 'minute';

                  if (!isMinuteMode && min !== 0) return '';
                  const timeLine = isMinuteMode ? `${h12}:${minStr} ${ampm}` : `${h12} ${ampm}`;

                  // Major ticks (day boundaries) get a second line with the date
                  if (ticks[index].major) {
                    const dayNames = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
                    const monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                    const dateStr = `${dayNames[d.getDay()]} ${monthNames[d.getMonth()]} ${d.getDate()}`;
                    return [timeLine, dateStr];
                  }
                  return timeLine;
                }
              }
            },
            y: yConfig,
            y2: y2Config
          }
        },
        plugins: [highlightPlugin, {
          id: 'customTimeTicks',
          beforeUpdate(chart) {
            // Dynamically set time unit and stepSize based on data range
            const xScale = chart.options.scales.x;
            if (!xScale || xScale.type !== 'time') return;
            let minT = Infinity, maxT = -Infinity;
            chart.data.datasets.forEach(ds => {
              ds.data.forEach(pt => {
                const t = pt.x ? pt.x.getTime() : 0;
                if (t > 0 && t < minT) minT = t;
                if (t > maxT) maxT = t;
              });
            });
            if (minT === Infinity) return;
            const rangeHours = (maxT - minT) / (1000 * 60 * 60);
            let unit, step;
            if (rangeHours < 1) {
              unit = 'minute';
              const rangeMins = rangeHours * 60;
              if (rangeMins <= 10) step = 1;
              else if (rangeMins <= 30) step = 5;
              else step = 10;
            } else {
              unit = 'hour';
              if (rangeHours <= 12) step = 1;
              else if (rangeHours <= 24) step = 2;
              else if (rangeHours <= 48) step = 4;
              else if (rangeHours <= 96) step = 6;
              else if (rangeHours <= 192) step = 8;
              else step = 12;
            }
            xScale.time.unit = unit;
            xScale.time.stepSize = step;
          },
          afterBuildTicks(chart) {
            // After Chart.js builds the time ticks, mark day-boundary ticks as major
            // so they are never auto-skipped and get the date label
            const xScale = chart.scales.x;
            if (!xScale || !xScale.ticks || xScale.ticks.length === 0) return;

            let lastDay = -1;
            xScale.ticks.forEach(tick => {
              const d = new Date(tick.value);
              const day = d.getDate();
              if (day !== lastDay) {
                tick.major = true;
                lastDay = day;
              }
            });
          }
        }]
      });

      // Auto-highlight the Weighted Avg line on load
      const avgIdx = datasets.findIndex(ds => ds.label === 'Weighted Avg');
      if (avgIdx >= 0) {
        highlightPlugin._highlight(mainChart, avgIdx);
      }
    }

    function renderHeatmap(snapshots, selectedCities, filterZeros, blipSet) {
      if (snapshots.length === 0) return;
      const latestIdx = snapshots.length - 1;
      const latest = snapshots[latestIdx];
      const table = document.getElementById('heatmapTable');

      let html = '<thead><tr><th>Product</th>';
      selectedCities.forEach(c => { html += `<th>${c}</th>`; });
      html += '</tr></thead><tbody>';

      latest.products.forEach(prod => {
        html += `<tr><td>${prod.model}</td>`;
        selectedCities.forEach(city => {
          const val = getValidValue(latest, prod.model, city, filterZeros, blipSet, latestIdx);
          if (val === null) {
            html += `<td style="background:var(--grid-color);color:var(--text-dimmer);">N/A</td>`;
          } else {
            const isLight = document.documentElement.getAttribute('data-theme') === 'light';
            const hue = val * 1.2; // 0=red, 120=green
            const bg = isLight ? `hsl(${hue}, 60%, 88%)` : `hsl(${hue}, 70%, 25%)`;
            const fg = isLight ? `hsl(${hue}, 70%, 30%)` : `hsl(${hue}, 70%, 85%)`;
            html += `<td style="background:${bg};color:${fg};font-weight:600;">${val}%</td>`;
          }
        });
        html += '</tr>';
      });
      html += '</tbody>';
      table.innerHTML = html;
    }

    let _moverPeriodHours = 24;
    let _moverUpdatesCount = null; // null = use hours mode, number = use last N updates mode

    /** Helper: compute average for a set of snapshots for a given city */
    function _avgForSnaps(snaps, allSnapshots, city, isAllProducts, selectedProduct, filterZeros, blipSet) {
      let vals = [];
      snaps.forEach(s => {
        const si = allSnapshots.indexOf(s);
        const products = isAllProducts ? s.products.map(p => p.model) : [selectedProduct];
        products.forEach(prod => {
          const val = getValidValue(s, prod, city, filterZeros, blipSet, si);
          if (val !== null) vals.push(val);
        });
      });
      return vals.length ? vals.reduce((a, b) => a + b, 0) / vals.length : null;
    }

    function _updatePeriodButtons(containerSelector, dataSpanHours) {
      document.querySelectorAll(`${containerSelector} .period-btn`).forEach(btn => {
        const h = parseInt(btn.dataset.hours);
        if (h > 0 && dataSpanHours < h * 0.5) {
          btn.classList.add('disabled');
        } else {
          btn.classList.remove('disabled');
        }
      });
    }

    function renderCitySummary(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet) {
      const grid = document.getElementById('citySummary');
      grid.innerHTML = '';

      selectedCities.forEach(city => {
        const avg = _avgForSnaps(snapshots, snapshots, city, isAllProducts, selectedProduct, filterZeros, blipSet);
        const display = avg !== null ? avg.toFixed(0) : 'N/A';
        const cls = avg !== null ? (avg >= 75 ? 'good' : avg >= 50 ? 'ok' : 'bad') : '';
        const card = document.createElement('div');
        card.className = 'summary-card';
        card.innerHTML = `
          <div class="city-name">${city}</div>
          <div class="avg-val ${cls}">${display}${avg !== null ? '%' : ''}</div>
        `;
        grid.appendChild(card);
      });
    }

    /**
     * Get the interpolated/extrapolated average for a city at a target time.
     * Uses the two nearest snapshots on either side of targetMs to interpolate.
     * If targetMs is before all data, uses earliest; if after all, uses latest.
     */
    function _interpolatedAvgAtTime(snapshots, targetMs, city, isAllProducts, selectedProduct, filterZeros, blipSet) {
      // Build time-series of (timestamp, avg) for this city
      const series = [];
      snapshots.forEach((s, si) => {
        const t = new Date(s.timestamp).getTime();
        const products = isAllProducts ? s.products.map(p => p.model) : [selectedProduct];
        let vals = [];
        products.forEach(prod => {
          const val = getValidValue(s, prod, city, filterZeros, blipSet, si);
          if (val !== null) vals.push(val);
        });
        if (vals.length > 0) {
          series.push({ t, avg: vals.reduce((a, b) => a + b, 0) / vals.length });
        }
      });
      if (series.length === 0) return null;

      // Find the two points bracketing targetMs
      let before = null, after = null;
      for (let i = 0; i < series.length; i++) {
        if (series[i].t <= targetMs) before = series[i];
        if (series[i].t >= targetMs && after === null) after = series[i];
      }

      // Exact match or only one side available
      if (before && after && before.t === after.t) return before.avg;
      if (before && after) {
        // Linear interpolation
        const frac = (targetMs - before.t) / (after.t - before.t);
        return before.avg + frac * (after.avg - before.avg);
      }
      if (before) return before.avg;
      if (after) return after.avg;
      return null;
    }

    function renderMovers(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet) {
      const grid = document.getElementById('moversGrid');
      grid.innerHTML = '';

      const now = snapshots.length > 0 ? new Date(snapshots[snapshots.length - 1].timestamp).getTime() : Date.now();
      const earliest = snapshots.length > 0 ? new Date(snapshots[0].timestamp).getTime() : now;
      const dataSpanHours = (now - earliest) / (1000 * 60 * 60);

      _updatePeriodButtons('#moverPeriodBtns', dataSpanHours);

      let recentSnaps, pastSnaps, usePastSnaps, isExtrapolated, targetPastMs;

      // Check if we're in "last N updates" mode
      if (_moverUpdatesCount !== null && _moverUpdatesCount > 0) {
        const n = Math.min(_moverUpdatesCount, snapshots.length - 1);
        if (n < 1 || snapshots.length < 2) {
          grid.innerHTML = '<div style="color:var(--text-dimmer);font-size:13px;padding:12px;">Not enough data updates yet.</div>';
          return;
        }
        // Use a small window (up to 3 snapshots) around each point
        // to be resilient to individual ERR/null values
        const lastIdx = snapshots.length - 1;
        const pastIdx = lastIdx - n;
        recentSnaps = snapshots.slice(Math.max(0, lastIdx - 1), lastIdx + 1);
        pastSnaps = snapshots.slice(Math.max(0, pastIdx - 1), Math.min(snapshots.length, pastIdx + 2));
        usePastSnaps = true;
        isExtrapolated = false;
        targetPastMs = null;
      } else {
        // Hours-based mode
        const periodMs = _moverPeriodHours * 60 * 60 * 1000;
        // "Recent" = last 25% of the period window; "Past" = the 25% window ending at period-ago
        const recentWindow = Math.max(periodMs * 0.25, 4 * 60 * 60 * 1000); // at least 4h

        recentSnaps = snapshots.filter(s => new Date(s.timestamp).getTime() >= now - recentWindow);

        // Try to find past snapshots in the normal window
        pastSnaps = snapshots.filter(s => {
          const t = new Date(s.timestamp).getTime();
          return t >= (now - periodMs - recentWindow) && t <= (now - periodMs);
        });

        usePastSnaps = pastSnaps.length > 0;
        isExtrapolated = !usePastSnaps;
        targetPastMs = now - periodMs;
      }

      if (recentSnaps.length === 0) {
        grid.innerHTML = '<div style="color:var(--text-dimmer);font-size:13px;padding:12px;">Not enough data for this period yet.</div>';
        return;
      }

      // Compute deltas for all cities
      const movers = [];

      selectedCities.forEach(city => {
        const recent = _avgForSnaps(recentSnaps, snapshots, city, isAllProducts, selectedProduct, filterZeros, blipSet);
        let past;
        if (usePastSnaps) {
          past = _avgForSnaps(pastSnaps, snapshots, city, isAllProducts, selectedProduct, filterZeros, blipSet);
        } else {
          // Extrapolate: find interpolated value at the target past time
          past = _interpolatedAvgAtTime(snapshots, targetPastMs, city, isAllProducts, selectedProduct, filterZeros, blipSet);
        }
        if (recent !== null && past !== null) {
          movers.push({ city, delta: recent - past, recent, past, extrapolated: isExtrapolated });
        }
      });

      // Sort by absolute delta (biggest moves first)
      movers.sort((a, b) => Math.abs(b.delta) - Math.abs(a.delta));

      movers.forEach(m => {
        const sign = m.delta >= 0 ? '+' : '';
        const cls = m.delta > 0 ? 'good' : m.delta < 0 ? 'bad' : 'neutral';
        const arrow = m.delta > 0 ? '‚ñ≤' : m.delta < 0 ? '‚ñº' : '';
        const extraNote = m.extrapolated ? ' ~' : '';
        const card = document.createElement('div');
        card.className = 'summary-card';
        card.innerHTML = `
          <div class="city-name">${m.city}</div>
          <div class="delta-val ${cls}">${arrow} ${sign}${m.delta.toFixed(1)}%${extraNote}</div>
          <div class="sub-label">${m.extrapolated ? '~' : ''}${m.past.toFixed(0)}% ‚Üí ${m.recent.toFixed(0)}%</div>
        `;
        grid.appendChild(card);
      });

      if (movers.length > 0 && movers[0].extrapolated) {
        const note = document.createElement('div');
        note.style.cssText = 'color:#555;font-size:11px;padding:4px 0 0 4px;width:100%;';
        note.textContent = '~ = estimated from interpolated past data (not enough snapshots at exact period boundary)';
        grid.appendChild(note);
      }
    }

    function renderProductChart(snapshots, selectedCities, filterZeros, blipSet) {
      const ctx = document.getElementById('productChart');
      if (productChart) {
        productChart.destroy();
        productChart = null;
      }

      document.getElementById('productChartTitle').textContent = 'Average Availability by Product (Store-Weighted)';

      const productAvgs = [];
      let overallWSum = 0, overallWTotal = 0;

      DATA.all_models.forEach((model, idx) => {
        let wSum = 0, wTotal = 0;
        snapshots.forEach((s, si) => {
          selectedCities.forEach(city => {
            const sc = s.cities.find(c => c.name === city);
            const storeCount = (sc && sc.store_count > 0) ? sc.store_count : 0;
            if (storeCount <= 0) return;
            const val = getValidValue(s, model, city, filterZeros, blipSet, si);
            if (val !== null) {
              wSum += val * storeCount;
              wTotal += storeCount;
            }
          });
        });
        if (wTotal > 0) {
          productAvgs.push({
            model,
            avg: wSum / wTotal,
            count: wTotal,
            color: PRODUCT_COLORS[idx % PRODUCT_COLORS.length]
          });
          overallWSum += wSum;
          overallWTotal += wTotal;
        }
      });

      productAvgs.sort((a, b) => a.avg - b.avg);

      // Add weighted average as first item
      const isLightTheme = document.documentElement.getAttribute('data-theme') === 'light';
      const avgBarColor = isLightTheme ? '#1d1d1f' : '#ffffff';
      if (overallWTotal > 0) {
        productAvgs.unshift({
          model: '‚öñÔ∏è Weighted Average (All Products)',
          avg: overallWSum / overallWTotal,
          count: overallWTotal,
          color: avgBarColor,
          isAverage: true
        });
      }

      // Store original colors for highlight/reset
      const origBgColors = productAvgs.map(p => p.isAverage ? avgBarColor + '55' : p.color + '99');
      const origBorderColors = productAvgs.map(p => p.color);
      const origBorderWidths = productAvgs.map(p => p.isAverage ? 2 : 1);

      // Highlight state
      let highlightedIdx = -1;

      productChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: productAvgs.map(p => p.model),
          datasets: [{
            label: 'Availability',
            data: productAvgs.map(p => p.avg),
            backgroundColor: [...origBgColors],
            borderColor: [...origBorderColors],
            borderWidth: [...origBorderWidths]
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          onClick: (event, elements) => {
            if (elements.length > 0) {
              const idx = elements[0].index;
              if (highlightedIdx === idx) {
                // Clicking same bar resets
                resetBarHighlight();
              } else {
                highlightBar(idx);
              }
            } else {
              resetBarHighlight();
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: '#aaa',
                generateLabels: function(chart) {
                  return productAvgs.map((p, i) => ({
                    text: p.model,
                    fontColor: p.color,
                    fillStyle: p.isAverage ? avgBarColor + '55' : p.color + '99',
                    strokeStyle: p.color,
                    lineWidth: p.isAverage ? 2 : 1,
                    hidden: false,
                    index: i
                  }));
                }
              },
              onClick: (e, legendItem, legend) => {
                const idx = legendItem.index;
                if (highlightedIdx === idx) {
                  resetBarHighlight();
                } else {
                  highlightBar(idx);
                }
              }
            },
            tooltip: {
              backgroundColor: getThemeColors().tooltipBg,
              borderColor: getThemeColors().tooltipBorder,
              borderWidth: 1,
              callbacks: {
                label: ctx => `${ctx.parsed.x.toFixed(1)}% (weighted across ${productAvgs[ctx.dataIndex].count} store-checks)`
              }
            }
          },
          scales: {
            x: {
              min: 0, max: 100,
              grid: { color: getThemeColors().grid },
              ticks: { color: getThemeColors().tick, callback: v => v + '%' }
            },
            y: {
              grid: { display: false },
              ticks: { color: getThemeColors().tickLabel, font: { size: 11 } }
            }
          }
        }
      });

      function highlightBar(idx) {
        highlightedIdx = idx;
        const ds = productChart.data.datasets[0];
        ds.backgroundColor = productAvgs.map((p, i) =>
          i === idx ? (p.isAverage ? avgBarColor + 'cc' : p.color + 'ff') : (p.isAverage ? avgBarColor + '15' : p.color + '22')
        );
        ds.borderColor = productAvgs.map((p, i) =>
          i === idx ? p.color : p.color + '44'
        );
        ds.borderWidth = productAvgs.map((p, i) =>
          i === idx ? 3 : 1
        );
        productChart.update('none');
      }

      function resetBarHighlight() {
        highlightedIdx = -1;
        const ds = productChart.data.datasets[0];
        ds.backgroundColor = [...origBgColors];
        ds.borderColor = [...origBorderColors];
        ds.borderWidth = [...origBorderWidths];
        productChart.update('none');
      }
    }

    let _csvData = ''; // cached for download

    function renderDataMatrix(snapshots, selectedCities, filterZeros, isAllProducts, selectedProduct, blipSet) {
      const card = document.getElementById('dataMatrixCard');
      const table = document.getElementById('dataMatrixTable');
      const title = document.getElementById('dataMatrixTitle');

      if (isAllProducts || snapshots.length === 0) {
        card.style.display = 'none';
        return;
      }

      card.style.display = 'block';
      title.textContent = `${selectedProduct} ‚Äî Availability by City Over Time`;

      // Get latest store counts for column headers
      const latestSnap = snapshots[snapshots.length - 1];
      function getCityStoreCount(cityName) {
        const c = latestSnap ? latestSnap.cities.find(c => c.name === cityName) : null;
        return (c && c.store_count > 0) ? c.store_count : '?';
      }

      // Build table: rows = timestamps, cols = cities
      let html = '<thead><tr><th style="min-width:160px;">Timestamp</th>';
      selectedCities.forEach(c => { html += `<th>${c} (${getCityStoreCount(c)})</th>`; });
      html += '<th>Weighted Avg</th></tr></thead><tbody>';

      // Also build CSV
      let csv = 'Timestamp,' + selectedCities.map(c => `${c} (${getCityStoreCount(c)})`).join(',') + ',Weighted Avg\n';

      snapshots.forEach((s, si) => {
        const ts = s.timestamp.replace('T', ' ').slice(0, 19);
        html += `<tr><td style="white-space:nowrap;color:var(--text-label);">${ts}</td>`;
        let csvRow = ts;

        const _isLight = document.documentElement.getAttribute('data-theme') === 'light';
        let wSum = 0, wTotal = 0;
        selectedCities.forEach(city => {
          const val = getValidValue(s, selectedProduct, city, filterZeros, blipSet, si);
          const sc = s.cities.find(c => c.name === city);
          const storeCount = (sc && sc.store_count > 0) ? sc.store_count : 0;

          if (val === null) {
            html += `<td style="background:var(--grid-color);color:var(--text-dimmer);">‚Äî</td>`;
            csvRow += ',';
          } else {
            const hue = val * 1.2;
            const bg = _isLight ? `hsl(${hue}, 60%, 88%)` : `hsl(${hue}, 70%, 25%)`;
            const fg = _isLight ? `hsl(${hue}, 70%, 30%)` : `hsl(${hue}, 70%, 85%)`;
            html += `<td style="background:${bg};color:${fg};font-weight:600;">${val}%</td>`;
            csvRow += `,${val}%`;
            if (storeCount > 0) {
              wSum += val * storeCount;
              wTotal += storeCount;
            }
          }
        });

        const wAvg = wTotal > 0 ? (wSum / wTotal).toFixed(1) : '';
        if (wAvg) {
          const hue = parseFloat(wAvg) * 1.2;
          const bg = _isLight ? `hsl(${hue}, 60%, 88%)` : `hsl(${hue}, 70%, 25%)`;
          const fg = _isLight ? `hsl(${hue}, 70%, 30%)` : `hsl(${hue}, 70%, 85%)`;
          html += `<td style="background:${bg};color:${fg};font-weight:700;">${wAvg}%</td>`;
        } else {
          html += `<td style="background:var(--grid-color);color:var(--text-dimmer);">‚Äî</td>`;
        }
        csvRow += `,${wAvg ? wAvg + '%' : ''}`;

        html += '</tr>';
        csv += csvRow + '\n';
      });

      html += '</tbody>';
      table.innerHTML = html;
      _csvData = csv;
    }

    document.getElementById('downloadCsv').addEventListener('click', () => {
      if (!_csvData) return;
      const product = getSelectedProduct();
      const safeName = product.replace(/[^a-zA-Z0-9]/g, '_');
      const blob = new Blob([_csvData], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `availability_${safeName}.csv`;
      a.click();
      URL.revokeObjectURL(url);
    });

    // Theme toggle
    function getThemeColors() {
      const isLight = document.documentElement.getAttribute('data-theme') === 'light';
      return {
        grid: isLight ? '#e5e5ea' : '#1a1a1a',
        tick: isLight ? '#86868b' : '#666',
        tickLabel: isLight ? '#6e6e73' : '#aaa',
        tooltipBg: isLight ? '#fff' : '#1a1a2e',
        tooltipBorder: isLight ? '#d1d1d6' : '#333',
      };
    }

    function applyThemeToCharts() {
      const tc = getThemeColors();
      [mainChart, productChart].forEach(chart => {
        if (!chart) return;
        const opts = chart.options;
        if (opts.plugins && opts.plugins.tooltip) {
          opts.plugins.tooltip.backgroundColor = tc.tooltipBg;
          opts.plugins.tooltip.borderColor = tc.tooltipBorder;
          opts.plugins.tooltip.titleColor = document.documentElement.getAttribute('data-theme') === 'light' ? '#1d1d1f' : '#fff';
          opts.plugins.tooltip.bodyColor = document.documentElement.getAttribute('data-theme') === 'light' ? '#1d1d1f' : '#e0e0e0';
        }
        if (opts.scales) {
          Object.values(opts.scales).forEach(scale => {
            if (scale.grid) scale.grid.color = tc.grid;
            if (scale.ticks) scale.ticks.color = scale.ticks.callback ? tc.tick : tc.tickLabel;
          });
        }
        chart.update('none');
      });
    }

    document.getElementById('themeToggle').addEventListener('click', () => {
      const html = document.documentElement;
      const isCurrentlyLight = html.getAttribute('data-theme') === 'light';
      const newTheme = isCurrentlyLight ? 'dark' : 'light';
      html.setAttribute('data-theme', newTheme === 'light' ? 'light' : '');
      if (newTheme === 'dark') html.removeAttribute('data-theme');
      else html.setAttribute('data-theme', 'light');
      document.getElementById('themeToggle').textContent = newTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
      localStorage.setItem('theme', newTheme);
      applyThemeToCharts();
      swapMapTiles();
      render(); // re-render heatmaps/data matrix with correct colors
    });

    // Restore saved theme
    (function() {
      const saved = localStorage.getItem('theme');
      if (saved === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
        document.getElementById('themeToggle').textContent = '‚òÄÔ∏è';
      }
    })();

    // ==========================================================
    // Interactive Map with Voronoi-Clipped Gradient Circles
    // ==========================================================

    const MAP_COLORS = {
      available: [48, 209, 88],    // green
      unavailable: [255, 59, 48],  // red
      nodata: [142, 142, 147],     // gray
      deltaUp: [48, 209, 88],      // green (improved)
      deltaDown: [255, 59, 48],    // red (declined)
      deltaFlat: [255, 159, 10],   // orange (no change)
      deltaNoData: [142, 142, 147],// gray (missing data)
    };
    const MILES_RADIUS = 50;
    /** Clustering distance thresholds by zoom level */
    function clusterDistanceForZoom(zoom) {
      if (zoom >= 7) return 0;    // no clustering
      if (zoom >= 6) return 50;   // city-level (Houston, Austin stay separate)
      if (zoom >= 5) return 250;  // state-level (Houston+Austin‚ÜíTexas, NYC+Boston‚ÜíNortheast)
      return 500;                 // regional (Southeast, etc.)
    }

    let mapMode = 'snapshot'; // 'snapshot' or 'delta'

    function milesToPixels(lat, zoom) {
      const metersPerPixel = (156543.03392 * Math.cos(lat * Math.PI / 180)) / Math.pow(2, zoom);
      return (MILES_RADIUS * 1609.34) / metersPerPixel;
    }

    function lerpColor(c1, c2, t) {
      return [
        Math.round(c1[0] + (c2[0] - c1[0]) * t),
        Math.round(c1[1] + (c2[1] - c1[1]) * t),
        Math.round(c1[2] + (c2[2] - c1[2]) * t),
      ];
    }

    /** Map fraction 0..1 to red(0) -> yellow(0.5) -> green(1) */
    function availabilityColor(fraction) {
      if (fraction <= 0.5) {
        return lerpColor(MAP_COLORS.unavailable, [255, 214, 10], fraction * 2);
      }
      return lerpColor([255, 214, 10], MAP_COLORS.available, (fraction - 0.5) * 2);
    }

    /** Delta color: -1 (red) -> 0 (orange) -> +1 (green). null = gray (no data). */
    function deltaColor(delta, hasData) {
      if (hasData === false) return MAP_COLORS.deltaNoData;
      if (delta > 0) return lerpColor(MAP_COLORS.deltaFlat, MAP_COLORS.deltaUp, Math.min(delta, 1));
      if (delta < 0) return lerpColor(MAP_COLORS.deltaFlat, MAP_COLORS.deltaDown, Math.min(-delta, 1));
      return MAP_COLORS.deltaFlat;
    }

    /** Haversine distance in miles between two lat/lng pairs */
    function haversineMiles(lat1, lng1, lat2, lng2) {
      const R = 3958.8; // Earth radius in miles
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLng = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLng / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    // US state abbreviation to full name
    const STATE_NAMES = {
      'AL':'Alabama','AK':'Alaska','AZ':'Arizona','AR':'Arkansas','CA':'California',
      'CO':'Colorado','CT':'Connecticut','DE':'Delaware','FL':'Florida','GA':'Georgia',
      'HI':'Hawaii','ID':'Idaho','IL':'Illinois','IN':'Indiana','IA':'Iowa','KS':'Kansas',
      'KY':'Kentucky','LA':'Louisiana','ME':'Maine','MD':'Maryland','MA':'Massachusetts',
      'MI':'Michigan','MN':'Minnesota','MS':'Mississippi','MO':'Missouri','MT':'Montana',
      'NE':'Nebraska','NV':'Nevada','NH':'New Hampshire','NJ':'New Jersey','NM':'New Mexico',
      'NY':'New York','NC':'North Carolina','ND':'North Dakota','OH':'Ohio','OK':'Oklahoma',
      'OR':'Oregon','PA':'Pennsylvania','RI':'Rhode Island','SC':'South Carolina',
      'SD':'South Dakota','TN':'Tennessee','TX':'Texas','UT':'Utah','VT':'Vermont',
      'VA':'Virginia','WA':'Washington','WV':'West Virginia','WI':'Wisconsin','WY':'Wyoming',
      'DC':'Washington DC',
    };

    /** Cluster stores by distance (BFS). distMiles controls merge radius. */
    function clusterStoresByDistance(stores, distMiles) {
      const assigned = new Array(stores.length).fill(-1);
      const clusters = [];

      for (let i = 0; i < stores.length; i++) {
        if (assigned[i] >= 0) continue;
        const clusterIdx = clusters.length;
        const group = [i];
        assigned[i] = clusterIdx;

        let queue = [i];
        while (queue.length > 0) {
          const cur = queue.shift();
          for (let j = 0; j < stores.length; j++) {
            if (assigned[j] >= 0) continue;
            const d = haversineMiles(stores[cur].lat, stores[cur].lng, stores[j].lat, stores[j].lng);
            if (d <= distMiles) {
              assigned[j] = clusterIdx;
              group.push(j);
              queue.push(j);
            }
          }
        }
        clusters.push(group);
      }

      return clusters.map(indices => {
        const groupStores = indices.map(i => stores[i]);
        const latAvg = groupStores.reduce((s, st) => s + st.lat, 0) / groupStores.length;
        const lngAvg = groupStores.reduce((s, st) => s + st.lng, 0) / groupStores.length;

        // Count stores per city and per state
        const cityCounts = {};
        const stateCounts = {};
        groupStores.forEach(s => {
          const k = `${s.city}, ${s.state}`;
          cityCounts[k] = (cityCounts[k] || 0) + 1;
          stateCounts[s.state] = (stateCounts[s.state] || 0) + 1;
        });

        const states = Object.keys(stateCounts);
        const topCityEntry = Object.entries(cityCounts).sort((a, b) => b[1] - a[1])[0];
        const topCity = topCityEntry[0];
        const [cityName, stateAbbr] = topCity.split(', ');

        // Determine display label based on cluster composition
        let displayName;
        if (states.length === 1) {
          // All same state ‚Äî use state name
          displayName = STATE_NAMES[states[0]] || states[0];
        } else {
          // Multiple states ‚Äî use the state with the most stores
          const topState = Object.entries(stateCounts).sort((a, b) => b[1] - a[1])[0][0];
          displayName = (STATE_NAMES[topState] || topState) + ' region';
        }

        return {
          lat: latAvg,
          lng: lngAvg,
          city: displayName,
          state: stateAbbr || '',
          name: displayName,
          stores: groupStores,
          _isCluster: true,
          _color: null,
          _availCount: 0,
          _totalCount: groupStores.length,
          _fraction: 0,
        };
      });
    }

    /**
     * VoronoiHeatmapLayer ‚Äî Leaflet canvas overlay.
     * Each store/cluster gets a radial gradient circle clipped to its Voronoi cell,
     * with center dot and Voronoi boundary lines.
     */
    const VoronoiHeatmapLayer = L.Layer.extend({
      initialize(options) {
        L.Util.setOptions(this, options);
        this._items = []; // stores or clusters
        this._canvas = null;
      },

      onAdd(map) {
        this._map = map;
        this._canvas = L.DomUtil.create('canvas', 'voronoi-canvas');
        this._canvas.style.position = 'absolute';
        this._canvas.style.top = '0';
        this._canvas.style.left = '0';
        this._canvas.style.pointerEvents = 'none';
        map.getPanes().overlayPane.appendChild(this._canvas);

        map.on('moveend zoomend resize', this._redraw, this);
        this._redraw();
      },

      onRemove(map) {
        L.DomUtil.remove(this._canvas);
        map.off('moveend zoomend resize', this._redraw, this);
      },

      setItems(items) {
        this._items = items;
        if (this._map) this._redraw();
      },

      _redraw() {
        const map = this._map;
        const size = map.getSize();
        const canvas = this._canvas;
        const dpr = window.devicePixelRatio || 1;

        canvas.width = size.x * dpr;
        canvas.height = size.y * dpr;
        canvas.style.width = size.x + 'px';
        canvas.style.height = size.y + 'px';

        const topLeft = map.containerPointToLayerPoint([0, 0]);
        L.DomUtil.setPosition(canvas, topLeft);

        const ctx = canvas.getContext('2d');
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, size.x, size.y);

        const items = this._items;
        if (!items || items.length === 0) return;

        const zoom = map.getZoom();

        // Project to pixels
        const points = items.map(s => {
          const pt = map.latLngToContainerPoint([s.lat, s.lng]);
          return [pt.x, pt.y];
        });

        // Voronoi
        const delaunay = d3.Delaunay.from(points);
        const voronoi = delaunay.voronoi([0, 0, size.x, size.y]);

        const isLight = document.documentElement.getAttribute('data-theme') === 'light';

        // Draw gradient circles clipped to both Voronoi cell AND 50mi radius
        items.forEach((item, i) => {
          const [px, py] = points[i];
          const color = item._color || MAP_COLORS.nodata;
          const opacity = 0.55;
          const radiusPx = Math.max(10, milesToPixels(item.lat, zoom));

          const cell = voronoi.cellPolygon(i);
          if (!cell) return;

          ctx.save();

          // Clip to intersection of Voronoi cell and circle
          ctx.beginPath();
          ctx.moveTo(cell[0][0], cell[0][1]);
          for (let j = 1; j < cell.length; j++) {
            ctx.lineTo(cell[j][0], cell[j][1]);
          }
          ctx.closePath();
          ctx.clip();

          // Second clip: the 50mi circle
          ctx.beginPath();
          ctx.arc(px, py, radiusPx, 0, Math.PI * 2);
          ctx.clip();

          // Radial gradient ‚Äî linear fade
          const grad = ctx.createRadialGradient(px, py, 0, px, py, radiusPx);
          grad.addColorStop(0, `rgba(${color[0]},${color[1]},${color[2]},${opacity})`);
          grad.addColorStop(0.3, `rgba(${color[0]},${color[1]},${color[2]},${opacity * 0.7})`);
          grad.addColorStop(0.6, `rgba(${color[0]},${color[1]},${color[2]},${opacity * 0.35})`);
          grad.addColorStop(1, `rgba(${color[0]},${color[1]},${color[2]},0)`);
          ctx.fillStyle = grad;
          ctx.fillRect(px - radiusPx, py - radiusPx, radiusPx * 2, radiusPx * 2);

          ctx.restore();

          // Center dot
          const dotRadius = item._isCluster ? 5 : 3;
          ctx.beginPath();
          ctx.arc(px, py, dotRadius, 0, Math.PI * 2);
          ctx.fillStyle = `rgb(${color[0]},${color[1]},${color[2]})`;
          ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.6)';
          ctx.lineWidth = 1;
          ctx.stroke();
        });

        // Draw Voronoi boundary lines (only within overlapping circle regions)
        ctx.strokeStyle = isLight ? 'rgba(0,0,0,0.15)' : 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        // For each Voronoi edge, draw it clipped to both adjacent circles
        for (let i = 0; i < items.length; i++) {
          const cell = voronoi.cellPolygon(i);
          if (!cell) continue;
          const [px, py] = points[i];
          const radiusPx = Math.max(10, milesToPixels(items[i].lat, zoom));

          ctx.save();
          // Clip to this store's circle
          ctx.beginPath();
          ctx.arc(px, py, radiusPx, 0, Math.PI * 2);
          ctx.clip();

          ctx.beginPath();
          ctx.moveTo(cell[0][0], cell[0][1]);
          for (let j = 1; j < cell.length; j++) {
            ctx.lineTo(cell[j][0], cell[j][1]);
          }
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }

        // Cluster labels (when clustered)
        items.forEach((item, i) => {
          if (!item._isCluster) return;
          const [px, py] = points[i];
          const pct = item._totalCount > 0 ? Math.round(item._fraction * 100) : 0;
          const cityLabel = item.city || item.name;
          const statsLabel = `${item._availCount}/${item._totalCount} (${pct}%)`;

          ctx.textAlign = 'center';

          // City name label
          ctx.font = 'bold 12px -apple-system, sans-serif';
          const cityW = ctx.measureText(cityLabel).width;
          ctx.font = '10px -apple-system, sans-serif';
          const statsW = ctx.measureText(statsLabel).width;
          const maxW = Math.max(cityW, statsW);

          const pillX = px - maxW / 2 - 6;
          const pillY = py + 8;
          const pillH = 30;
          ctx.fillStyle = isLight ? 'rgba(255,255,255,0.88)' : 'rgba(0,0,0,0.75)';
          ctx.beginPath();
          ctx.roundRect(pillX, pillY, maxW + 12, pillH, 5);
          ctx.fill();

          ctx.fillStyle = isLight ? '#1d1d1f' : '#e0e0e0';
          ctx.font = 'bold 12px -apple-system, sans-serif';
          ctx.textBaseline = 'top';
          ctx.fillText(cityLabel, px, pillY + 3);

          ctx.font = '10px -apple-system, sans-serif';
          ctx.fillStyle = isLight ? '#6e6e73' : '#aaa';
          ctx.fillText(statsLabel, px, pillY + 17);
        });
      },

      findNearest(containerPoint) {
        if (!this._items || this._items.length === 0) return null;
        const map = this._map;
        let minDist = Infinity;
        let nearest = null;
        this._items.forEach(s => {
          const pt = map.latLngToContainerPoint([s.lat, s.lng]);
          const d = Math.hypot(pt.x - containerPoint.x, pt.y - containerPoint.y);
          if (d < minDist) { minDist = d; nearest = s; }
        });
        return minDist < 100 ? nearest : null;
      }
    });

    function getMapTileUrl() {
      const isLight = document.documentElement.getAttribute('data-theme') === 'light';
      return isLight
        ? 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png'
        : 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png';
    }

    /** Get the store_map snapshot closest to a given timestamp index (0-based) */
    function getStoreAvailAtIndex(snapIdx) {
      if (!DATA || !DATA.store_map) return {};
      const snaps = DATA.store_map.snapshots;
      if (snapIdx < 0 || snapIdx >= snaps.length) return {};
      return snaps[snapIdx].a; // {storeNumber: {product: 0|1}}
    }

    function formatMapTimestamp(isoStr) {
      const d = new Date(isoStr);
      const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const h = d.getHours(), m = d.getMinutes();
      const ampm = h >= 12 ? 'PM' : 'AM';
      const h12 = h % 12 || 12;
      return `${months[d.getMonth()]} ${d.getDate()} ${h12}:${m < 10 ? '0' + m : m} ${ampm}`;
    }

    function initMap() {
      if (leafletMap) {
        leafletMap.invalidateSize();
        return;
      }

      const container = document.getElementById('mapContainer');
      if (!container) return;

      leafletMap = L.map(container, {
        center: [39.5, -98.5],
        zoom: 5,
        zoomControl: true,
      });

      mapTileLayer = L.tileLayer(getMapTileUrl(), {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        maxZoom: 18,
      }).addTo(leafletMap);

      voronoiLayer = new VoronoiHeatmapLayer();
      voronoiLayer.addTo(leafletMap);

      // Tooltip
      mapTooltipEl = document.createElement('div');
      mapTooltipEl.className = 'map-tooltip';
      mapTooltipEl.style.display = 'none';
      container.appendChild(mapTooltipEl);

      leafletMap.on('mousemove', (e) => {
        if (!voronoiLayer) return;
        const item = voronoiLayer.findNearest(e.containerPoint);
        if (item) {
          let html = '';
          if (item._isCluster) {
            const pct = item._totalCount > 0 ? Math.round(item._fraction * 100) : 0;
            html = `<strong>${item.city}, ${item.state}</strong><br>`;
            html += `${item._availCount}/${item._totalCount} stores (${pct}%)`;
            if (mapMode === 'delta' && item._delta !== undefined) {
              const sign = item._delta > 0 ? '+' : '';
              html += `<br>Delta: ${sign}${Math.round(item._delta * 100)}%`;
            }
          } else {
            html = `<strong>${item.name}</strong><br>${item.city}, ${item.state}<br>`;
            if (mapMode === 'delta') {
              if (item._delta !== undefined) {
                const sign = item._delta > 0 ? '+' : '';
                html += `Delta: <span style="color:${item._delta > 0 ? '#30d158' : item._delta < 0 ? '#ff3b30' : '#8e8e93'};">${sign}${Math.round(item._delta * 100)}%</span>`;
              }
            } else {
              const product = getSelectedProduct();
              if (product === '__ALL__') {
                const avail = item._availCount || 0;
                const total = item._totalProducts || 0;
                html += `${avail}/${total} products available`;
              } else {
                const a = item._avail;
                if (a === undefined) {
                  html += '<span style="color:#8e8e93;">No data</span>';
                } else {
                  html += a ? '<span style="color:#30d158;">Available</span>' : '<span style="color:#ff3b30;">Unavailable</span>';
                }
              }
            }
          }
          mapTooltipEl.innerHTML = html;
          mapTooltipEl.style.display = 'block';
          mapTooltipEl.style.left = (e.containerPoint.x + 12) + 'px';
          mapTooltipEl.style.top = (e.containerPoint.y - 12) + 'px';
        } else {
          mapTooltipEl.style.display = 'none';
        }
      });

      leafletMap.on('mouseout', () => {
        if (mapTooltipEl) mapTooltipEl.style.display = 'none';
      });

      // Redraw on zoom change (for clustering)
      leafletMap.on('zoomend', () => { updateMapOverlay(); });

      // Legend
      const legend = L.control({ position: 'bottomright' });
      legend.onAdd = function() {
        const div = L.DomUtil.create('div', 'map-legend');
        div.id = 'mapLegend';
        div.innerHTML =
          '<span class="map-legend-dot" style="background:rgb(48,209,88);"></span> Available<br>' +
          '<span class="map-legend-dot" style="background:rgb(255,214,10);"></span> Partial<br>' +
          '<span class="map-legend-dot" style="background:rgb(255,59,48);"></span> Unavailable<br>' +
          '<span class="map-legend-dot" style="background:rgb(142,142,147);"></span> No data';
        return div;
      };
      legend.addTo(leafletMap);

      // Map time slider
      initMapTimeControls();

      // Stats badge
      if (DATA && DATA.store_map) {
        const sm = DATA.store_map;
        const numStores = sm.stores.length;
        const numSnapshots = sm.snapshots.length;
        const numCities = new Set(sm.stores.map(s => `${s.city}, ${s.state}`)).size;
        const totalDatapoints = numStores * numSnapshots;
        // (stats box removed ‚Äî info is shown in controls above/below map)
      }
    }

    /** Build evenly-spaced date tick marks for a slider */
    function buildTimeTicks(container, snaps, numTicks) {
      container.innerHTML = '';
      if (snaps.length < 2) return;
      const count = Math.min(numTicks, snaps.length);
      for (let i = 0; i < count; i++) {
        const idx = Math.round(i * (snaps.length - 1) / (count - 1));
        const label = document.createElement('span');
        label.style.cssText = 'font-size:9px;color:var(--text-dim);white-space:nowrap;';
        const d = new Date(snaps[idx].t);
        const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
        const h = d.getHours(), m = d.getMinutes();
        const ampm = h >= 12 ? 'PM' : 'AM';
        const h12 = h % 12 || 12;
        label.textContent = `${months[d.getMonth()]} ${d.getDate()} ${h12}:${m < 10 ? '0' + m : m}${ampm}`;
        container.appendChild(label);
      }
    }

    function initMapTimeControls() {
      if (!DATA || !DATA.store_map) return;
      const snaps = DATA.store_map.snapshots;
      const max = snaps.length - 1;

      // Snapshot slider
      const slider = document.getElementById('mapTimeSlider');
      slider.max = max;
      slider.value = max;
      document.getElementById('mapTimeLabel').textContent = formatMapTimestamp(snaps[max].t);
      buildTimeTicks(document.getElementById('mapTimeTicks'), snaps, 7);

      slider.addEventListener('input', () => {
        const idx = parseInt(slider.value);
        document.getElementById('mapTimeLabel').textContent = formatMapTimestamp(snaps[idx].t);
        updateMapOverlay();
      });

      // Delta controls
      const dStart = document.getElementById('mapDeltaStart');
      const dEnd = document.getElementById('mapDeltaEnd');
      dStart.max = max;
      dEnd.max = max;
      dStart.value = 0;
      dEnd.value = max;

      buildTimeTicks(document.getElementById('mapDeltaTicks'), snaps, 7);

      function updateDeltaLabel() {
        const si = parseInt(dStart.value);
        const ei = parseInt(dEnd.value);
        document.getElementById('mapDeltaSelectedLabel').textContent =
          formatMapTimestamp(snaps[si].t) + ' ‚Üí ' + formatMapTimestamp(snaps[ei].t);
      }
      updateDeltaLabel();

      dStart.addEventListener('input', () => {
        if (parseInt(dStart.value) > parseInt(dEnd.value)) dStart.value = dEnd.value;
        updateDeltaLabel();
        updateMapOverlay();
      });
      dEnd.addEventListener('input', () => {
        if (parseInt(dEnd.value) < parseInt(dStart.value)) dEnd.value = dStart.value;
        updateDeltaLabel();
        updateMapOverlay();
      });

      // Mode buttons
      document.querySelectorAll('.map-mode-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          document.querySelectorAll('.map-mode-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          mapMode = btn.dataset.mode;
          document.getElementById('mapSnapshotControls').style.display = mapMode === 'snapshot' ? '' : 'none';
          document.getElementById('mapDeltaControls').style.display = mapMode === 'delta' ? 'flex' : 'none';
          // Update legend
          const leg = document.getElementById('mapLegend');
          if (leg) {
            if (mapMode === 'delta') {
              leg.innerHTML =
                '<span class="map-legend-dot" style="background:rgb(48,209,88);"></span> Improved<br>' +
                '<span class="map-legend-dot" style="background:rgb(255,159,10);"></span> No change<br>' +
                '<span class="map-legend-dot" style="background:rgb(255,59,48);"></span> Declined<br>' +
                '<span class="map-legend-dot" style="background:rgb(142,142,147);"></span> No data';
            } else {
              leg.innerHTML =
                '<span class="map-legend-dot" style="background:rgb(48,209,88);"></span> Available<br>' +
                '<span class="map-legend-dot" style="background:rgb(255,214,10);"></span> Partial<br>' +
                '<span class="map-legend-dot" style="background:rgb(255,59,48);"></span> Unavailable<br>' +
                '<span class="map-legend-dot" style="background:rgb(142,142,147);"></span> No data';
            }
          }
          updateMapOverlay();
        });
      });
    }

    /** Compute per-store availability fraction for a given snapshot index and product */
    function computeStoreItems(snapIdx) {
      if (!DATA || !DATA.store_map) return [];
      const product = getSelectedProduct();
      const isAll = product === '__ALL__';
      const avail = getStoreAvailAtIndex(snapIdx);

      return DATA.store_map.stores.map(s => {
        const store = { ...s, _avail: undefined, _availCount: 0, _totalProducts: 0, _fraction: 0 };
        const storeAvail = avail[s.id] || {};

        if (isAll) {
          const products = Object.keys(storeAvail);
          store._totalProducts = products.length;
          store._availCount = products.filter(p => storeAvail[p] === 1).length;
          store._fraction = products.length > 0 ? store._availCount / products.length : 0;
          store._color = products.length > 0 ? availabilityColor(store._fraction) : MAP_COLORS.nodata;
        } else {
          const a = storeAvail[product];
          store._avail = a;
          if (a === undefined) {
            store._color = MAP_COLORS.nodata;
            store._fraction = 0;
          } else {
            store._fraction = a;
            store._color = a ? MAP_COLORS.available : MAP_COLORS.unavailable;
            store._availCount = a;
            store._totalProducts = 1;
          }
        }
        return store;
      });
    }

    /** Compute per-store delta between two snapshot indices */
    function computeDeltaItems(startIdx, endIdx) {
      if (!DATA || !DATA.store_map) return [];
      const product = getSelectedProduct();
      const isAll = product === '__ALL__';
      const availStart = getStoreAvailAtIndex(startIdx);
      const availEnd = getStoreAvailAtIndex(endIdx);

      return DATA.store_map.stores.map(s => {
        const store = { ...s, _delta: 0, _hasData: true };
        const aStart = availStart[s.id] || {};
        const aEnd = availEnd[s.id] || {};

        if (isAll) {
          const allProducts = new Set([...Object.keys(aStart), ...Object.keys(aEnd)]);
          if (allProducts.size === 0) {
            store._delta = 0;
            store._hasData = false;
            store._color = deltaColor(0, false);
          } else {
            const fracStart = [...allProducts].filter(p => aStart[p] === 1).length / allProducts.size;
            const fracEnd = [...allProducts].filter(p => aEnd[p] === 1).length / allProducts.size;
            store._delta = fracEnd - fracStart;
            store._fraction = fracEnd;
            store._color = deltaColor(store._delta, true);
          }
        } else {
          const vs = aStart[product];
          const ve = aEnd[product];
          if (vs === undefined && ve === undefined) {
            store._delta = 0;
            store._hasData = false;
            store._color = deltaColor(0, false);
          } else {
            store._delta = (ve || 0) - (vs || 0);
            store._fraction = ve || 0;
            store._color = deltaColor(store._delta, true);
          }
        }
        return store;
      });
    }

    function updateMapOverlay() {
      if (!DATA || !DATA.store_map || !voronoiLayer || !leafletMap) return;

      let items;
      if (mapMode === 'delta') {
        const si = parseInt(document.getElementById('mapDeltaStart').value);
        const ei = parseInt(document.getElementById('mapDeltaEnd').value);
        items = computeDeltaItems(si, ei);
      } else {
        const snapIdx = parseInt(document.getElementById('mapTimeSlider').value);
        items = computeStoreItems(snapIdx);
      }

      // Hierarchical clustering by zoom level
      const zoom = leafletMap.getZoom();
      const clusterDist = clusterDistanceForZoom(zoom);
      if (clusterDist > 0) {
        const clusters = clusterStoresByDistance(items, clusterDist);
        clusters.forEach(c => {
          if (mapMode === 'delta') {
            const withData = c.stores.filter(s => s._hasData !== false);
            if (withData.length === 0) {
              c._delta = 0;
              c._fraction = 0;
              c._color = deltaColor(0, false);
            } else {
              const avgDelta = withData.reduce((a, s) => a + (s._delta || 0), 0) / withData.length;
              c._delta = avgDelta;
              c._fraction = avgDelta;
              c._color = deltaColor(avgDelta, true);
            }
            c._availCount = c.stores.filter(s => (s._delta || 0) > 0).length;
          } else {
            const fracs = c.stores.map(s => s._fraction || 0);
            const avg = fracs.reduce((a, b) => a + b, 0) / fracs.length;
            c._fraction = avg;
            c._color = availabilityColor(avg);
            const product = getSelectedProduct();
            const isAll = product === '__ALL__';
            if (isAll) {
              c._availCount = c.stores.filter(s => s._fraction > 0.5).length;
            } else {
              c._availCount = c.stores.filter(s => s._avail === 1).length;
            }
          }
        });
        voronoiLayer.setItems(clusters);
      } else {
        voronoiLayer.setItems(items);
      }
    }

    function swapMapTiles() {
      if (!mapTileLayer || !leafletMap) return;
      leafletMap.removeLayer(mapTileLayer);
      mapTileLayer = L.tileLayer(getMapTileUrl(), {
        attribution: '&copy; <a href="https://carto.com/">CARTO</a>',
        maxZoom: 18,
      }).addTo(leafletMap);
    }

    loadData();
  </script>

  <footer style="text-align:center;padding:24px;color:var(--text-dimmer);font-size:12px;border-top:1px solid var(--footer-border);margin-top:24px;">
  </footer>
</body>
</html>
